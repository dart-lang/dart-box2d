        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>RevoluteJoint class / box2d Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="box2d" data-type="RevoluteJoint">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../box2d.html">box2d</a> &rsaquo; <a href="../box2d/RevoluteJoint.html">RevoluteJoint</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>RevoluteJoint</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class RevoluteJoint extends Joint {
 final Vector2 localAnchor1 = new Vector2.zero();
 final Vector2 localAnchor2 = new Vector2.zero();

 final Vector3 impulse = new Vector3.zero();

 double _motorImpulse = 0.0;

 // Effective mass for point-to-point constraint.
 final Matrix3 mass = new Matrix3.zero();

 // Effective mass for motor/limit angular constraint.
 double motorMass;

 bool _enableMotor;

 double _maxMotorTorque;

 double _motorSpeed;

 bool _enableLimit;

 double referenceAngle;

 /** Limits on the relative rotation of the joint. */
 double lowerAngle;
 double upperAngle;

 int limitState;

 RevoluteJoint(RevoluteJointDef def) : super(def) {
   localAnchor1.setFrom(def.localAnchorA);
   localAnchor2.setFrom(def.localAnchorB);
   referenceAngle = def.referenceAngle;
   lowerAngle = def.lowerAngle;
   upperAngle = def.upperAngle;
   _maxMotorTorque = def.maxMotorTorque;
   _motorSpeed = def.motorSpeed;
   _enableLimit = def.enableLimit;
   _enableMotor = def.enableMotor;
 }

 void initVelocityConstraints(TimeStep step) {
   final Body b1 = bodyA;
   final Body b2 = bodyB;

   if (_enableMotor || _enableLimit) {
     // You cannot create a rotation limit between bodies that
     // both have fixed rotation.
     assert (b1.invInertia &gt; 0.0 || b2.invInertia &gt; 0.0);
   }

   final Vector2 r1 = new Vector2.zero();
   final Vector2 r2 = new Vector2.zero();

   // Compute the effective mass matrix.
   r1.setFrom(localAnchor1).sub(b1.localCenter);
   r2.setFrom(localAnchor2).sub(b2.localCenter);
   b1.originTransform.rotation.transformed(r1, r1);
   b2.originTransform.rotation.transformed(r2, r2);

   num m1 = b1.invMass, m2 = b2.invMass;
   num i1 = b1.invInertia, i2 = b2.invInertia;

   mass.setValues(
     m1 + m2 + r1.y * r1.y * i1 + r2.y * r2.y * i2,
     -r1.y * r1.x * i1 - r2.y * r2.x * i2,
     -r1.y * i1 - r2.y * i2,

     -r1.y * r1.x * i1 - r2.y * r2.x * i2,
     m1 + m2 + r1.x * r1.x * i1 + r2.x * r2.x * i2,
     r1.x * i1 + r2.x * i2,

     -r1.y * i1 - r2.y * i2,
     r1.x * i1 + r2.x * i2,
     i1 + i2
   );

   motorMass = i1 + i2;
   if (motorMass &gt; 0.0) {
     motorMass = 1.0 / motorMass;
   }

   if (_enableMotor == false) {
     _motorImpulse = 0.0;
   }

   if (_enableLimit) {
     num jointAngle = b2.sweep.angle - b1.sweep.angle - referenceAngle;
     if ((upperAngle - lowerAngle).abs() &lt; 2.0 * Settings.ANGULAR_SLOP) {
       limitState = LimitState.EQUAL;
     }
     else if (jointAngle &lt;= lowerAngle) {
       if (limitState != LimitState.AT_LOWER) {
         impulse.z = 0.0;
       }
       limitState = LimitState.AT_LOWER;
     }
     else if (jointAngle &gt;= upperAngle) {
       if (limitState != LimitState.AT_UPPER) {
         impulse.z = 0.0;
       }
       limitState = LimitState.AT_UPPER;
     }
     else {
       limitState = LimitState.INACTIVE;
       impulse.z = 0.0;
     }
   }
   else {
     limitState = LimitState.INACTIVE;
   }

   if (step.warmStarting) {
     // Scale impulses to support a variable time step.
     impulse.scale(step.dtRatio);
     _motorImpulse *= step.dtRatio;

     Vector2 temp = new Vector2.zero();
     Vector2 P = new Vector2.zero();
     P.setValues(impulse.x, impulse.y);

     temp.setFrom(P).scale(m1);
     b1.linearVelocity.sub(temp);
     b1.angularVelocity -= i1 * (r1.cross(P) + _motorImpulse +
         impulse.z);

     temp.setFrom(P).scale(m2);
     b2.linearVelocity.add(temp);
     b2.angularVelocity += i2 * (r2.cross(P) + _motorImpulse +
         impulse.z);

   } else {
     impulse.setZero();
     _motorImpulse = 0.0;
   }
 }

 void solveVelocityConstraints(final TimeStep step) {
   final Body b1 = bodyA;
   final Body b2 = bodyB;

   final Vector2 v1 = b1.linearVelocity;
   num w1 = b1.angularVelocity;
   final Vector2 v2 = b2.linearVelocity;
   num w2 = b2.angularVelocity;

   num m1 = b1.invMass, m2 = b2.invMass;
   num i1 = b1.invInertia, i2 = b2.invInertia;

   // Solve motor constraint.
   if (_enableMotor &amp;&amp; limitState != LimitState.EQUAL) {
     num Cdot = w2 - w1 - _motorSpeed;
     num imp = motorMass * (-Cdot);
     num oldImpulse = _motorImpulse;
     num maxImpulse = step.dt * _maxMotorTorque;
     _motorImpulse = MathBox.clamp(_motorImpulse + imp, -maxImpulse,
         maxImpulse);
     imp = _motorImpulse - oldImpulse;

     w1 -= i1 * imp;
     w2 += i2 * imp;
   }

   final Vector2 temp = new Vector2.zero();
   final Vector2 r1 = new Vector2.zero();
   final Vector2 r2 = new Vector2.zero();

   // Solve limit constraint.
   if (_enableLimit &amp;&amp; limitState != LimitState.INACTIVE) {

     r1.setFrom(localAnchor1).sub(b1.localCenter);
     r2.setFrom(localAnchor2).sub(b2.localCenter);
     b1.originTransform.rotation.transformed(r1, r1);
     b2.originTransform.rotation.transformed(r2, r2);

     final Vector2 Cdot1 = new Vector2.zero();
     final Vector3 Cdot = new Vector3.zero();

     // Solve point-to-point constraint
     r1.scaleOrthogonalInto(w1, temp);
     r2.scaleOrthogonalInto(w2, Cdot1);
     Cdot1.add(v2).sub(v1).sub(temp);
     num Cdot2 = w2 - w1;
     Cdot.setValues(Cdot1.x, Cdot1.y, Cdot2);

     Vector3 imp = new Vector3.zero();
     Matrix3.solve(mass, imp, Cdot.negate());

     if (limitState == LimitState.EQUAL) {
       impulse.add(imp);
     } else if (limitState == LimitState.AT_LOWER) {
       num newImpulse = impulse.z + imp.z;
       if (newImpulse &lt; 0.0) {
         Matrix3.solve2(mass, temp, Cdot1.negate());
         imp.x = temp.x;
         imp.y = temp.y;
         imp.z = -impulse.z;
         impulse.x += temp.x;
         impulse.y += temp.y;
         impulse.z = 0.0;
       }
     } else if (limitState == LimitState.AT_UPPER) {
       num newImpulse = impulse.z + imp.z;
       if (newImpulse &gt; 0.0) {
         Matrix3.solve2(mass, temp, Cdot1.negate());
         imp.x = temp.x;
         imp.y = temp.y;
         imp.z = -impulse.z;
         impulse.x += temp.x;
         impulse.y += temp.y;
         impulse.z = 0.0;
       }
     }
     final Vector2 P = new Vector2.zero();

     P.setValues(imp.x, imp.y);

     temp.setFrom(P).scale(m1);
     v1.sub(temp);
     w1 -= i1 * (r1.cross(P) + imp.z);

     temp.setFrom(P).scale(m2);
     v2.add(temp);
     w2 += i2 * (r2.cross(P) + imp.z);

   } else {
     r1.setFrom(localAnchor1).sub(b1.localCenter);
     r2.setFrom(localAnchor2).sub(b2.localCenter);
     b1.originTransform.rotation.transformed(r1, r1);
     b2.originTransform.rotation.transformed(r2, r2);

     // Solve point-to-point constraint
     Vector2 Cdot = new Vector2.zero();
     Vector2 imp = new Vector2.zero();

     r1.scaleOrthogonalInto(w1, temp);
     r2.scaleOrthogonalInto(w2, Cdot);
     Cdot.add(v2).sub(v1).sub(temp);
     Matrix3.solve2(mass, imp, Cdot.negate()); // just leave negated

     impulse.x += imp.x;
     impulse.y += imp.y;

     temp.setFrom(imp).scale(m1);
     v1.sub(temp);
     w1 -= i1 * r1.cross(imp);

     temp.setFrom(imp).scale(m2);
     v2.add(temp);
     w2 += i2 * r2.cross(imp);
   }

   b1.angularVelocity = w1;
   b2.angularVelocity = w2;
 }

 bool solvePositionConstraints(num baumgarte) {
   final Body b1 = bodyA;
   final Body b2 = bodyB;

   num angularError = 0.0;
   num positionError = 0.0;

   // Solve angular limit constraint.
   if (_enableLimit &amp;&amp; limitState != LimitState.INACTIVE) {
     num angle = b2.sweep.angle - b1.sweep.angle - referenceAngle;
     num limitImpulse = 0.0;

     if (limitState == LimitState.EQUAL) {
       // Prevent large angular corrections
       num C = MathBox.clamp(angle - lowerAngle,
           -Settings.MAX_ANGULAR_CORRECTION, Settings.MAX_ANGULAR_CORRECTION);
       limitImpulse = -motorMass * C;
       angularError = C.abs();
     } else if (limitState == LimitState.AT_LOWER) {
       num C = angle - lowerAngle;
       angularError = -C;

       // Prevent large angular corrections and allow some slop.
       C = MathBox.clamp(C + Settings.ANGULAR_SLOP,
           -Settings.MAX_ANGULAR_CORRECTION, 0.0);
       limitImpulse = -motorMass * C;
     } else if (limitState == LimitState.AT_UPPER) {
       num C = angle - upperAngle;
       angularError = C;

       // Prevent large angular corrections and allow some slop.
       C = MathBox.clamp(C - Settings.ANGULAR_SLOP, 0.0,
           Settings.MAX_ANGULAR_CORRECTION);
       limitImpulse = -motorMass * C;
     }

     b1.sweep.angle -= b1.invInertia * limitImpulse;
     b2.sweep.angle += b2.invInertia * limitImpulse;

     b1.synchronizeTransform();
     b2.synchronizeTransform();
   }

   // Solve point-to-point constraint.
   {
     Vector2 imp = new Vector2.zero();

     Vector2 r1 = new Vector2.zero();
     Vector2 r2 = new Vector2.zero();
     Vector2 C = new Vector2.zero();

     r1.setFrom(localAnchor1).sub(b1.localCenter);
     r2.setFrom(localAnchor2).sub(b2.localCenter);
     b1.originTransform.rotation.transformed(r1, r1);
     b2.originTransform.rotation.transformed(r2, r2);

     C.setFrom(b2.sweep.center).add(r2);
     C.sub(b1.sweep.center).sub(r1);
     positionError = C.length;

     num invMass1 = b1.invMass, invMass2 = b2.invMass;
     num invI1 = b1.invInertia, invI2 = b2.invInertia;

     // Handle large detachment.
     final num k_allowedStretch = 10.0 * Settings.LINEAR_SLOP;
     if (C.length2 &gt; k_allowedStretch * k_allowedStretch) {
       Vector2 u = new Vector2.zero();

       // Use a particle solution (no rotation).
       num m = invMass1 + invMass2;
       if (m &gt; 0.0) {
         m = 1.0 / m;
       }
       imp.setFrom(C).negate().scale(m);
       final num k_beta = 0.5;
       // using u as temp variable
       u.setFrom(imp).scale(k_beta * invMass1);
       b1.sweep.center.sub(u);
       u.setFrom(imp).scale(k_beta * invMass2);
       b2.sweep.center.add(u);

       C.setFrom(b2.sweep.center).add(r2);
       C.sub(b1.sweep.center).sub(r1);
     }

     Matrix2 K1 = new Matrix2(
      invMass1 + invMass2,
      0.0,
      0.0,
      invMass1 + invMass2);

     Matrix2 K2 = new Matrix2(
      invI1 * r1.y * r1.y,
      -invI1 * r1.x * r1.y,
      -invI1 * r1.x * r1.y,
      invI1 * r1.x * r1.x);

     Matrix2 K3 = new Matrix2(
      invI2 * r2.y * r2.y,
      -invI2 * r2.x * r2.y,
      -invI2 * r2.x * r2.y,
      invI2 * r2.x * r2.x);

     K1.add(K2).add(K3);
     Matrix2.solve(K1, imp, C.negate()); // just leave c negated

     // using C as temp variable
     C.setFrom(imp).scale(b1.invMass);
     b1.sweep.center.sub(C);
     b1.sweep.angle -= b1.invInertia * r1.cross(imp);

     C.setFrom(imp).scale(b2.invMass);
     b2.sweep.center.add(C);
     b2.sweep.angle += b2.invInertia * r2.cross(imp);

     b1.synchronizeTransform();
     b2.synchronizeTransform();
   }

   return positionError &lt;= Settings.LINEAR_SLOP &amp;&amp; angularError &lt;=
       Settings.ANGULAR_SLOP;
 }

 void getAnchorA(Vector2 argOut) {
   bodyA.getWorldPointToOut(localAnchor1, argOut);
 }

 void getAnchorB(Vector2 argOut) {
   bodyB.getWorldPointToOut(localAnchor2, argOut);
 }

 void getReactionForce(num inv_dt, Vector2 argOut) {
   argOut.setValues(impulse.x, impulse.y).scale(inv_dt);
 }

 num getReactionTorque(num inv_dt) {
   return inv_dt * impulse.z;
 }

 num get jointAngle {
   final Body b1 = bodyA;
   final Body b2 = bodyB;
   return b2.sweep.angle - b1.sweep.angle - referenceAngle;
 }

 num get jointSpeed {
   final Body b1 = bodyA;
   final Body b2 = bodyB;
   return b2.angularVelocity - b1.angularVelocity;
 }

 bool get motorEnabled =&gt; _enableMotor;

 void set motorEnabled(bool flag) {
   bodyA.awake = true;
   bodyB.awake = true;
   _enableMotor = flag;
 }

 num get motorTorque =&gt; _motorImpulse;

 void set motorSpeed(num speed) {
   bodyA.awake = true;
   bodyB.awake = true;
   _motorSpeed = speed;
 }

 num get motorSpeed =&gt; _motorSpeed;

 num get maxMotorTorque =&gt; _maxMotorTorque;

 void set maxMotorTorque(num torque) {
   bodyA.awake = true;
   bodyB.awake = true;
   _maxMotorTorque = torque;
 }

 bool get limitEnabled =&gt; _enableLimit;

 void set limitEnabled(bool flag) {
   bodyA.awake = true;
   bodyB.awake = true;
   _enableLimit = flag;
 }

 void setLimits(final num lower, final num upper) {
   assert (lower &lt;= upper);
   bodyA.awake = true;
   bodyB.awake = true;
   lowerAngle = lower;
   upperAngle = upper;
 }
}
</pre>
</div>
<h3>Extends</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../box2d/Joint.html">Joint</a></span>&nbsp;&gt;&nbsp;<span class="type-box"><span class="icon-class"></span><strong>RevoluteJoint</strong></span></p>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>RevoluteJoint</strong>(<a href="../box2d/RevoluteJointDef.html">RevoluteJointDef</a> def) <a class="anchor-link" href="#"
              title="Permalink to RevoluteJoint.RevoluteJoint">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Creates a new <a class="crossref" href="../dart_core/Object.html">Object</a> instance.</p>
<p><a class="crossref" href="../dart_core/Object.html">Object</a> instances have no meaningful state, and are only useful
through their identity. An <a class="crossref" href="../dart_core/Object.html">Object</a> instance is equal to itself
only.</p>
<div class="docs-inherited-from">docs inherited from <a href="http://api.dartlang.org/dart_core/Object.html">Object</a> </div></div>
<pre class="source">
RevoluteJoint(RevoluteJointDef def) : super(def) {
 localAnchor1.setFrom(def.localAnchorA);
 localAnchor2.setFrom(def.localAnchorB);
 referenceAngle = def.referenceAngle;
 lowerAngle = def.lowerAngle;
 upperAngle = def.upperAngle;
 _maxMotorTorque = def.maxMotorTorque;
 _motorSpeed = def.motorSpeed;
 _enableLimit = def.enableLimit;
 _enableMotor = def.enableMotor;
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field inherited"><h4 id="active">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>active</strong> <a class="anchor-link"
            href="#active"
            title="Permalink to RevoluteJoint.active">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../box2d/Joint.html">Joint</a> </div><div class="doc">
<p>Short-cut function to determine if either body is inactive. </p>
<pre class="source">
bool get active =&gt; bodyA.active &amp;&amp; bodyB.active;
</pre>
</div>
</div>
<div class="field inherited"><h4 id="bodyA">
<button class="show-code">Code</button>
<a href="../box2d/Body.html">Body</a>         <strong>bodyA</strong> <a class="anchor-link"
            href="#bodyA"
            title="Permalink to RevoluteJoint.bodyA">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../box2d/Joint.html">Joint</a> </div><div class="doc">
<pre class="source">
Body bodyA
</pre>
</div>
</div>
<div class="field inherited"><h4 id="bodyB">
<button class="show-code">Code</button>
<a href="../box2d/Body.html">Body</a>         <strong>bodyB</strong> <a class="anchor-link"
            href="#bodyB"
            title="Permalink to RevoluteJoint.bodyB">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../box2d/Joint.html">Joint</a> </div><div class="doc">
<pre class="source">
Body bodyB
</pre>
</div>
</div>
<div class="field inherited"><h4 id="collideConnected">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>collideConnected</strong> <a class="anchor-link"
            href="#collideConnected"
            title="Permalink to RevoluteJoint.collideConnected">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../box2d/Joint.html">Joint</a> </div><div class="doc">
<pre class="source">
bool collideConnected
</pre>
</div>
</div>
<div class="field inherited"><h4 id="edgeA">
<button class="show-code">Code</button>
<a href="../box2d/JointEdge.html">JointEdge</a>         <strong>edgeA</strong> <a class="anchor-link"
            href="#edgeA"
            title="Permalink to RevoluteJoint.edgeA">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../box2d/Joint.html">Joint</a> </div><div class="doc">
<pre class="source">
JointEdge edgeA = new JointEdge()
</pre>
</div>
</div>
<div class="field inherited"><h4 id="edgeB">
<button class="show-code">Code</button>
<a href="../box2d/JointEdge.html">JointEdge</a>         <strong>edgeB</strong> <a class="anchor-link"
            href="#edgeB"
            title="Permalink to RevoluteJoint.edgeB">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../box2d/Joint.html">Joint</a> </div><div class="doc">
<pre class="source">
JointEdge edgeB = new JointEdge()
</pre>
</div>
</div>
<div class="field"><h4 id="impulse">
<button class="show-code">Code</button>
final <a href="../vector_math/Vector3.html">Vector3</a>         <strong>impulse</strong> <a class="anchor-link"
            href="#impulse"
            title="Permalink to RevoluteJoint.impulse">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final Vector3 impulse = new Vector3.zero()
</pre>
</div>
</div>
<div class="field inherited"><h4 id="invIA">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/double.html">double</a>         <strong>invIA</strong> <a class="anchor-link"
            href="#invIA"
            title="Permalink to RevoluteJoint.invIA">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../box2d/Joint.html">Joint</a> </div><div class="doc">
<pre class="source">
double invIA
</pre>
</div>
</div>
<div class="field inherited"><h4 id="invIB">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/double.html">double</a>         <strong>invIB</strong> <a class="anchor-link"
            href="#invIB"
            title="Permalink to RevoluteJoint.invIB">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../box2d/Joint.html">Joint</a> </div><div class="doc">
<pre class="source">
double invIB
</pre>
</div>
</div>
<div class="field inherited"><h4 id="invMassA">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/double.html">double</a>         <strong>invMassA</strong> <a class="anchor-link"
            href="#invMassA"
            title="Permalink to RevoluteJoint.invMassA">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../box2d/Joint.html">Joint</a> </div><div class="doc">
<pre class="source">
double invMassA
</pre>
</div>
</div>
<div class="field inherited"><h4 id="invMassB">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/double.html">double</a>         <strong>invMassB</strong> <a class="anchor-link"
            href="#invMassB"
            title="Permalink to RevoluteJoint.invMassB">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../box2d/Joint.html">Joint</a> </div><div class="doc">
<pre class="source">
double invMassB
</pre>
</div>
</div>
<div class="field inherited"><h4 id="islandFlag">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>islandFlag</strong> <a class="anchor-link"
            href="#islandFlag"
            title="Permalink to RevoluteJoint.islandFlag">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../box2d/Joint.html">Joint</a> </div><div class="doc">
<pre class="source">
bool islandFlag = false
</pre>
</div>
</div>
<div class="field"><h4 id="jointAngle">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/num.html">num</a>         <strong>jointAngle</strong> <a class="anchor-link"
            href="#jointAngle"
            title="Permalink to RevoluteJoint.jointAngle">#</a>
        </h4>
        <div class="doc">
<pre class="source">
num get jointAngle {
 final Body b1 = bodyA;
 final Body b2 = bodyB;
 return b2.sweep.angle - b1.sweep.angle - referenceAngle;
}
</pre>
</div>
</div>
<div class="field"><h4 id="jointSpeed">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/num.html">num</a>         <strong>jointSpeed</strong> <a class="anchor-link"
            href="#jointSpeed"
            title="Permalink to RevoluteJoint.jointSpeed">#</a>
        </h4>
        <div class="doc">
<pre class="source">
num get jointSpeed {
 final Body b1 = bodyA;
 final Body b2 = bodyB;
 return b2.angularVelocity - b1.angularVelocity;
}
</pre>
</div>
</div>
<div class="field"><h4 id="limitEnabled">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>limitEnabled</strong> <a class="anchor-link"
            href="#limitEnabled"
            title="Permalink to RevoluteJoint.limitEnabled">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool get limitEnabled =&gt; _enableLimit;
</pre>
<pre class="source">
void set limitEnabled(bool flag) {
 bodyA.awake = true;
 bodyB.awake = true;
 _enableLimit = flag;
}
</pre>
</div>
</div>
<div class="field"><h4 id="limitState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/int.html">int</a>         <strong>limitState</strong> <a class="anchor-link"
            href="#limitState"
            title="Permalink to RevoluteJoint.limitState">#</a>
        </h4>
        <div class="doc">
<pre class="source">
int limitState
</pre>
</div>
</div>
<div class="field"><h4 id="localAnchor1">
<button class="show-code">Code</button>
final <a href="../vector_math/Vector2.html">Vector2</a>         <strong>localAnchor1</strong> <a class="anchor-link"
            href="#localAnchor1"
            title="Permalink to RevoluteJoint.localAnchor1">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final Vector2 localAnchor1 = new Vector2.zero()
</pre>
</div>
</div>
<div class="field"><h4 id="localAnchor2">
<button class="show-code">Code</button>
final <a href="../vector_math/Vector2.html">Vector2</a>         <strong>localAnchor2</strong> <a class="anchor-link"
            href="#localAnchor2"
            title="Permalink to RevoluteJoint.localAnchor2">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final Vector2 localAnchor2 = new Vector2.zero()
</pre>
</div>
</div>
<div class="field inherited"><h4 id="localCenterA">
<button class="show-code">Code</button>
final <a href="../vector_math/Vector2.html">Vector2</a>         <strong>localCenterA</strong> <a class="anchor-link"
            href="#localCenterA"
            title="Permalink to RevoluteJoint.localCenterA">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../box2d/Joint.html">Joint</a> </div><div class="doc">
<pre class="source">
final Vector2 localCenterA = new Vector2.zero()
</pre>
</div>
</div>
<div class="field inherited"><h4 id="localCenterB">
<button class="show-code">Code</button>
final <a href="../vector_math/Vector2.html">Vector2</a>         <strong>localCenterB</strong> <a class="anchor-link"
            href="#localCenterB"
            title="Permalink to RevoluteJoint.localCenterB">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../box2d/Joint.html">Joint</a> </div><div class="doc">
<pre class="source">
final Vector2 localCenterB = new Vector2.zero()
</pre>
</div>
</div>
<div class="field"><h4 id="lowerAngle">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/double.html">double</a>         <strong>lowerAngle</strong> <a class="anchor-link"
            href="#lowerAngle"
            title="Permalink to RevoluteJoint.lowerAngle">#</a>
        </h4>
        <div class="doc">
<p>Limits on the relative rotation of the joint. </p>
<pre class="source">
double lowerAngle
</pre>
</div>
</div>
<div class="field"><h4 id="mass">
<button class="show-code">Code</button>
final <a href="../vector_math/Matrix3.html">Matrix3</a>         <strong>mass</strong> <a class="anchor-link"
            href="#mass"
            title="Permalink to RevoluteJoint.mass">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final Matrix3 mass = new Matrix3.zero()
</pre>
</div>
</div>
<div class="field"><h4 id="maxMotorTorque">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/num.html">num</a>         <strong>maxMotorTorque</strong> <a class="anchor-link"
            href="#maxMotorTorque"
            title="Permalink to RevoluteJoint.maxMotorTorque">#</a>
        </h4>
        <div class="doc">
<pre class="source">
num get maxMotorTorque =&gt; _maxMotorTorque;
</pre>
<pre class="source">
void set maxMotorTorque(num torque) {
 bodyA.awake = true;
 bodyB.awake = true;
 _maxMotorTorque = torque;
}
</pre>
</div>
</div>
<div class="field"><h4 id="motorEnabled">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>motorEnabled</strong> <a class="anchor-link"
            href="#motorEnabled"
            title="Permalink to RevoluteJoint.motorEnabled">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool get motorEnabled =&gt; _enableMotor;
</pre>
<pre class="source">
void set motorEnabled(bool flag) {
 bodyA.awake = true;
 bodyB.awake = true;
 _enableMotor = flag;
}
</pre>
</div>
</div>
<div class="field"><h4 id="motorMass">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/double.html">double</a>         <strong>motorMass</strong> <a class="anchor-link"
            href="#motorMass"
            title="Permalink to RevoluteJoint.motorMass">#</a>
        </h4>
        <div class="doc">
<pre class="source">
double motorMass
</pre>
</div>
</div>
<div class="field"><h4 id="motorSpeed">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/num.html">num</a>         <strong>motorSpeed</strong> <a class="anchor-link"
            href="#motorSpeed"
            title="Permalink to RevoluteJoint.motorSpeed">#</a>
        </h4>
        <div class="doc">
<pre class="source">
num get motorSpeed =&gt; _motorSpeed;
</pre>
<pre class="source">
void set motorSpeed(num speed) {
 bodyA.awake = true;
 bodyB.awake = true;
 _motorSpeed = speed;
}
</pre>
</div>
</div>
<div class="field"><h4 id="motorTorque">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/num.html">num</a>         <strong>motorTorque</strong> <a class="anchor-link"
            href="#motorTorque"
            title="Permalink to RevoluteJoint.motorTorque">#</a>
        </h4>
        <div class="doc">
<pre class="source">
num get motorTorque =&gt; _motorImpulse;
</pre>
</div>
</div>
<div class="field"><h4 id="referenceAngle">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/double.html">double</a>         <strong>referenceAngle</strong> <a class="anchor-link"
            href="#referenceAngle"
            title="Permalink to RevoluteJoint.referenceAngle">#</a>
        </h4>
        <div class="doc">
<pre class="source">
double referenceAngle
</pre>
</div>
</div>
<div class="field inherited"><h4 id="type">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/int.html">int</a>         <strong>type</strong> <a class="anchor-link"
            href="#type"
            title="Permalink to RevoluteJoint.type">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../box2d/Joint.html">Joint</a> </div><div class="doc">
<pre class="source">
int type
</pre>
</div>
</div>
<div class="field"><h4 id="upperAngle">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/double.html">double</a>         <strong>upperAngle</strong> <a class="anchor-link"
            href="#upperAngle"
            title="Permalink to RevoluteJoint.upperAngle">#</a>
        </h4>
        <div class="doc">
<pre class="source">
double upperAngle
</pre>
</div>
</div>
<div class="field inherited"><h4 id="userData">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/Object.html">Object</a>         <strong>userData</strong> <a class="anchor-link"
            href="#userData"
            title="Permalink to RevoluteJoint.userData">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../box2d/Joint.html">Joint</a> </div><div class="doc">
<pre class="source">
Object userData
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method inherited"><h4 id="destructor">
<button class="show-code">Code</button>
void <strong>destructor</strong>() <a class="anchor-link" href="#destructor"
              title="Permalink to RevoluteJoint.destructor">#</a></h4>
<div class="inherited-from">inherited from <a href="../box2d/Joint.html">Joint</a> </div><div class="doc">
<p>Override to handle destruction of joint. </p>
<pre class="source">
void destructor() { }
</pre>
</div>
</div>
<div class="method"><h4 id="getAnchorA">
<button class="show-code">Code</button>
void <strong>getAnchorA</strong>(<a href="../vector_math/Vector2.html">Vector2</a> argOut) <a class="anchor-link" href="#getAnchorA"
              title="Permalink to RevoluteJoint.getAnchorA">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Get the anchor point on bodyA in world coordinates. </p>
<div class="docs-inherited-from">docs inherited from <a href="../box2d/Joint.html">Joint</a> </div></div>
<pre class="source">
void getAnchorA(Vector2 argOut) {
 bodyA.getWorldPointToOut(localAnchor1, argOut);
}
</pre>
</div>
</div>
<div class="method"><h4 id="getAnchorB">
<button class="show-code">Code</button>
void <strong>getAnchorB</strong>(<a href="../vector_math/Vector2.html">Vector2</a> argOut) <a class="anchor-link" href="#getAnchorB"
              title="Permalink to RevoluteJoint.getAnchorB">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Get the anchor point on bodyB in world coordinates. </p>
<div class="docs-inherited-from">docs inherited from <a href="../box2d/Joint.html">Joint</a> </div></div>
<pre class="source">
void getAnchorB(Vector2 argOut) {
 bodyB.getWorldPointToOut(localAnchor2, argOut);
}
</pre>
</div>
</div>
<div class="method"><h4 id="getReactionForce">
<button class="show-code">Code</button>
void <strong>getReactionForce</strong>(<a href="http://api.dartlang.org/dart_core/num.html">num</a> inv_dt, <a href="../vector_math/Vector2.html">Vector2</a> argOut) <a class="anchor-link" href="#getReactionForce"
              title="Permalink to RevoluteJoint.getReactionForce">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Get the reaction force on body2 at the joint anchor in Newtons. </p>
<div class="docs-inherited-from">docs inherited from <a href="../box2d/Joint.html">Joint</a> </div></div>
<pre class="source">
void getReactionForce(num inv_dt, Vector2 argOut) {
 argOut.setValues(impulse.x, impulse.y).scale(inv_dt);
}
</pre>
</div>
</div>
<div class="method"><h4 id="getReactionTorque">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/num.html">num</a> <strong>getReactionTorque</strong>(<a href="http://api.dartlang.org/dart_core/num.html">num</a> inv_dt) <a class="anchor-link" href="#getReactionTorque"
              title="Permalink to RevoluteJoint.getReactionTorque">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Get the reaction torque on body2 in N*m. </p>
<div class="docs-inherited-from">docs inherited from <a href="../box2d/Joint.html">Joint</a> </div></div>
<pre class="source">
num getReactionTorque(num inv_dt) {
 return inv_dt * impulse.z;
}
</pre>
</div>
</div>
<div class="method"><h4 id="initVelocityConstraints">
<button class="show-code">Code</button>
void <strong>initVelocityConstraints</strong>(<a href="../box2d/TimeStep.html">TimeStep</a> step) <a class="anchor-link" href="#initVelocityConstraints"
              title="Permalink to RevoluteJoint.initVelocityConstraints">#</a></h4>
<div class="doc">
<pre class="source">
void initVelocityConstraints(TimeStep step) {
 final Body b1 = bodyA;
 final Body b2 = bodyB;

 if (_enableMotor || _enableLimit) {
   // You cannot create a rotation limit between bodies that
   // both have fixed rotation.
   assert (b1.invInertia &gt; 0.0 || b2.invInertia &gt; 0.0);
 }

 final Vector2 r1 = new Vector2.zero();
 final Vector2 r2 = new Vector2.zero();

 // Compute the effective mass matrix.
 r1.setFrom(localAnchor1).sub(b1.localCenter);
 r2.setFrom(localAnchor2).sub(b2.localCenter);
 b1.originTransform.rotation.transformed(r1, r1);
 b2.originTransform.rotation.transformed(r2, r2);

 num m1 = b1.invMass, m2 = b2.invMass;
 num i1 = b1.invInertia, i2 = b2.invInertia;

 mass.setValues(
   m1 + m2 + r1.y * r1.y * i1 + r2.y * r2.y * i2,
   -r1.y * r1.x * i1 - r2.y * r2.x * i2,
   -r1.y * i1 - r2.y * i2,

   -r1.y * r1.x * i1 - r2.y * r2.x * i2,
   m1 + m2 + r1.x * r1.x * i1 + r2.x * r2.x * i2,
   r1.x * i1 + r2.x * i2,

   -r1.y * i1 - r2.y * i2,
   r1.x * i1 + r2.x * i2,
   i1 + i2
 );

 motorMass = i1 + i2;
 if (motorMass &gt; 0.0) {
   motorMass = 1.0 / motorMass;
 }

 if (_enableMotor == false) {
   _motorImpulse = 0.0;
 }

 if (_enableLimit) {
   num jointAngle = b2.sweep.angle - b1.sweep.angle - referenceAngle;
   if ((upperAngle - lowerAngle).abs() &lt; 2.0 * Settings.ANGULAR_SLOP) {
     limitState = LimitState.EQUAL;
   }
   else if (jointAngle &lt;= lowerAngle) {
     if (limitState != LimitState.AT_LOWER) {
       impulse.z = 0.0;
     }
     limitState = LimitState.AT_LOWER;
   }
   else if (jointAngle &gt;= upperAngle) {
     if (limitState != LimitState.AT_UPPER) {
       impulse.z = 0.0;
     }
     limitState = LimitState.AT_UPPER;
   }
   else {
     limitState = LimitState.INACTIVE;
     impulse.z = 0.0;
   }
 }
 else {
   limitState = LimitState.INACTIVE;
 }

 if (step.warmStarting) {
   // Scale impulses to support a variable time step.
   impulse.scale(step.dtRatio);
   _motorImpulse *= step.dtRatio;

   Vector2 temp = new Vector2.zero();
   Vector2 P = new Vector2.zero();
   P.setValues(impulse.x, impulse.y);

   temp.setFrom(P).scale(m1);
   b1.linearVelocity.sub(temp);
   b1.angularVelocity -= i1 * (r1.cross(P) + _motorImpulse +
       impulse.z);

   temp.setFrom(P).scale(m2);
   b2.linearVelocity.add(temp);
   b2.angularVelocity += i2 * (r2.cross(P) + _motorImpulse +
       impulse.z);

 } else {
   impulse.setZero();
   _motorImpulse = 0.0;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="setLimits">
<button class="show-code">Code</button>
void <strong>setLimits</strong>(<a href="http://api.dartlang.org/dart_core/num.html">num</a> lower, <a href="http://api.dartlang.org/dart_core/num.html">num</a> upper) <a class="anchor-link" href="#setLimits"
              title="Permalink to RevoluteJoint.setLimits">#</a></h4>
<div class="doc">
<pre class="source">
void setLimits(final num lower, final num upper) {
 assert (lower &lt;= upper);
 bodyA.awake = true;
 bodyB.awake = true;
 lowerAngle = lower;
 upperAngle = upper;
}
</pre>
</div>
</div>
<div class="method"><h4 id="solvePositionConstraints">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> <strong>solvePositionConstraints</strong>(<a href="http://api.dartlang.org/dart_core/num.html">num</a> baumgarte) <a class="anchor-link" href="#solvePositionConstraints"
              title="Permalink to RevoluteJoint.solvePositionConstraints">#</a></h4>
<div class="doc">
<div class="inherited">
<p>This returns true if the position errors are within tolerance. </p>
<div class="docs-inherited-from">docs inherited from <a href="../box2d/Joint.html">Joint</a> </div></div>
<pre class="source">
bool solvePositionConstraints(num baumgarte) {
 final Body b1 = bodyA;
 final Body b2 = bodyB;

 num angularError = 0.0;
 num positionError = 0.0;

 // Solve angular limit constraint.
 if (_enableLimit &amp;&amp; limitState != LimitState.INACTIVE) {
   num angle = b2.sweep.angle - b1.sweep.angle - referenceAngle;
   num limitImpulse = 0.0;

   if (limitState == LimitState.EQUAL) {
     // Prevent large angular corrections
     num C = MathBox.clamp(angle - lowerAngle,
         -Settings.MAX_ANGULAR_CORRECTION, Settings.MAX_ANGULAR_CORRECTION);
     limitImpulse = -motorMass * C;
     angularError = C.abs();
   } else if (limitState == LimitState.AT_LOWER) {
     num C = angle - lowerAngle;
     angularError = -C;

     // Prevent large angular corrections and allow some slop.
     C = MathBox.clamp(C + Settings.ANGULAR_SLOP,
         -Settings.MAX_ANGULAR_CORRECTION, 0.0);
     limitImpulse = -motorMass * C;
   } else if (limitState == LimitState.AT_UPPER) {
     num C = angle - upperAngle;
     angularError = C;

     // Prevent large angular corrections and allow some slop.
     C = MathBox.clamp(C - Settings.ANGULAR_SLOP, 0.0,
         Settings.MAX_ANGULAR_CORRECTION);
     limitImpulse = -motorMass * C;
   }

   b1.sweep.angle -= b1.invInertia * limitImpulse;
   b2.sweep.angle += b2.invInertia * limitImpulse;

   b1.synchronizeTransform();
   b2.synchronizeTransform();
 }

 // Solve point-to-point constraint.
 {
   Vector2 imp = new Vector2.zero();

   Vector2 r1 = new Vector2.zero();
   Vector2 r2 = new Vector2.zero();
   Vector2 C = new Vector2.zero();

   r1.setFrom(localAnchor1).sub(b1.localCenter);
   r2.setFrom(localAnchor2).sub(b2.localCenter);
   b1.originTransform.rotation.transformed(r1, r1);
   b2.originTransform.rotation.transformed(r2, r2);

   C.setFrom(b2.sweep.center).add(r2);
   C.sub(b1.sweep.center).sub(r1);
   positionError = C.length;

   num invMass1 = b1.invMass, invMass2 = b2.invMass;
   num invI1 = b1.invInertia, invI2 = b2.invInertia;

   // Handle large detachment.
   final num k_allowedStretch = 10.0 * Settings.LINEAR_SLOP;
   if (C.length2 &gt; k_allowedStretch * k_allowedStretch) {
     Vector2 u = new Vector2.zero();

     // Use a particle solution (no rotation).
     num m = invMass1 + invMass2;
     if (m &gt; 0.0) {
       m = 1.0 / m;
     }
     imp.setFrom(C).negate().scale(m);
     final num k_beta = 0.5;
     // using u as temp variable
     u.setFrom(imp).scale(k_beta * invMass1);
     b1.sweep.center.sub(u);
     u.setFrom(imp).scale(k_beta * invMass2);
     b2.sweep.center.add(u);

     C.setFrom(b2.sweep.center).add(r2);
     C.sub(b1.sweep.center).sub(r1);
   }

   Matrix2 K1 = new Matrix2(
    invMass1 + invMass2,
    0.0,
    0.0,
    invMass1 + invMass2);

   Matrix2 K2 = new Matrix2(
    invI1 * r1.y * r1.y,
    -invI1 * r1.x * r1.y,
    -invI1 * r1.x * r1.y,
    invI1 * r1.x * r1.x);

   Matrix2 K3 = new Matrix2(
    invI2 * r2.y * r2.y,
    -invI2 * r2.x * r2.y,
    -invI2 * r2.x * r2.y,
    invI2 * r2.x * r2.x);

   K1.add(K2).add(K3);
   Matrix2.solve(K1, imp, C.negate()); // just leave c negated

   // using C as temp variable
   C.setFrom(imp).scale(b1.invMass);
   b1.sweep.center.sub(C);
   b1.sweep.angle -= b1.invInertia * r1.cross(imp);

   C.setFrom(imp).scale(b2.invMass);
   b2.sweep.center.add(C);
   b2.sweep.angle += b2.invInertia * r2.cross(imp);

   b1.synchronizeTransform();
   b2.synchronizeTransform();
 }

 return positionError &lt;= Settings.LINEAR_SLOP &amp;&amp; angularError &lt;=
     Settings.ANGULAR_SLOP;
}
</pre>
</div>
</div>
<div class="method"><h4 id="solveVelocityConstraints">
<button class="show-code">Code</button>
void <strong>solveVelocityConstraints</strong>(<a href="../box2d/TimeStep.html">TimeStep</a> step) <a class="anchor-link" href="#solveVelocityConstraints"
              title="Permalink to RevoluteJoint.solveVelocityConstraints">#</a></h4>
<div class="doc">
<pre class="source">
void solveVelocityConstraints(final TimeStep step) {
 final Body b1 = bodyA;
 final Body b2 = bodyB;

 final Vector2 v1 = b1.linearVelocity;
 num w1 = b1.angularVelocity;
 final Vector2 v2 = b2.linearVelocity;
 num w2 = b2.angularVelocity;

 num m1 = b1.invMass, m2 = b2.invMass;
 num i1 = b1.invInertia, i2 = b2.invInertia;

 // Solve motor constraint.
 if (_enableMotor &amp;&amp; limitState != LimitState.EQUAL) {
   num Cdot = w2 - w1 - _motorSpeed;
   num imp = motorMass * (-Cdot);
   num oldImpulse = _motorImpulse;
   num maxImpulse = step.dt * _maxMotorTorque;
   _motorImpulse = MathBox.clamp(_motorImpulse + imp, -maxImpulse,
       maxImpulse);
   imp = _motorImpulse - oldImpulse;

   w1 -= i1 * imp;
   w2 += i2 * imp;
 }

 final Vector2 temp = new Vector2.zero();
 final Vector2 r1 = new Vector2.zero();
 final Vector2 r2 = new Vector2.zero();

 // Solve limit constraint.
 if (_enableLimit &amp;&amp; limitState != LimitState.INACTIVE) {

   r1.setFrom(localAnchor1).sub(b1.localCenter);
   r2.setFrom(localAnchor2).sub(b2.localCenter);
   b1.originTransform.rotation.transformed(r1, r1);
   b2.originTransform.rotation.transformed(r2, r2);

   final Vector2 Cdot1 = new Vector2.zero();
   final Vector3 Cdot = new Vector3.zero();

   // Solve point-to-point constraint
   r1.scaleOrthogonalInto(w1, temp);
   r2.scaleOrthogonalInto(w2, Cdot1);
   Cdot1.add(v2).sub(v1).sub(temp);
   num Cdot2 = w2 - w1;
   Cdot.setValues(Cdot1.x, Cdot1.y, Cdot2);

   Vector3 imp = new Vector3.zero();
   Matrix3.solve(mass, imp, Cdot.negate());

   if (limitState == LimitState.EQUAL) {
     impulse.add(imp);
   } else if (limitState == LimitState.AT_LOWER) {
     num newImpulse = impulse.z + imp.z;
     if (newImpulse &lt; 0.0) {
       Matrix3.solve2(mass, temp, Cdot1.negate());
       imp.x = temp.x;
       imp.y = temp.y;
       imp.z = -impulse.z;
       impulse.x += temp.x;
       impulse.y += temp.y;
       impulse.z = 0.0;
     }
   } else if (limitState == LimitState.AT_UPPER) {
     num newImpulse = impulse.z + imp.z;
     if (newImpulse &gt; 0.0) {
       Matrix3.solve2(mass, temp, Cdot1.negate());
       imp.x = temp.x;
       imp.y = temp.y;
       imp.z = -impulse.z;
       impulse.x += temp.x;
       impulse.y += temp.y;
       impulse.z = 0.0;
     }
   }
   final Vector2 P = new Vector2.zero();

   P.setValues(imp.x, imp.y);

   temp.setFrom(P).scale(m1);
   v1.sub(temp);
   w1 -= i1 * (r1.cross(P) + imp.z);

   temp.setFrom(P).scale(m2);
   v2.add(temp);
   w2 += i2 * (r2.cross(P) + imp.z);

 } else {
   r1.setFrom(localAnchor1).sub(b1.localCenter);
   r2.setFrom(localAnchor2).sub(b2.localCenter);
   b1.originTransform.rotation.transformed(r1, r1);
   b2.originTransform.rotation.transformed(r2, r2);

   // Solve point-to-point constraint
   Vector2 Cdot = new Vector2.zero();
   Vector2 imp = new Vector2.zero();

   r1.scaleOrthogonalInto(w1, temp);
   r2.scaleOrthogonalInto(w2, Cdot);
   Cdot.add(v2).sub(v1).sub(temp);
   Matrix3.solve2(mass, imp, Cdot.negate()); // just leave negated

   impulse.x += imp.x;
   impulse.y += imp.y;

   temp.setFrom(imp).scale(m1);
   v1.sub(temp);
   w1 -= i1 * r1.cross(imp);

   temp.setFrom(imp).scale(m2);
   v2.add(temp);
   w2 += i2 * r2.cross(imp);
 }

 b1.angularVelocity = w1;
 b2.angularVelocity = w2;
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
