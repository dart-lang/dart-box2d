        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>World class / box2d Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="box2d" data-type="World">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../box2d.html">box2d</a> &rsaquo; <a href="../box2d/World.html">World</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>World</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class World {
 static const int WORLD_POOL_SIZE = 100;
 static const int WORLD_POOL_CONTAINER_SIZE = 10;

 static const int NEW_FIXTURE = 0x0001;
 static const int LOCKED = 0x0002;
 static const int CLEAR_FORCES = 0x0004;

 int _flags;

 ContactManager _contactManager;

 Body _bodyList;
 Joint _jointList;

 int _bodyCount;
 int _jointCount;

 final Vector2 _gravity;
 bool _allowSleep;

 DebugDraw _debugDraw;

 FixtureDestructionListener _fixtureDestructionListener;
 JointDestructionListener _jointDestructionListener;

 final DefaultWorldPool _pool;

 /**
  * This is used to compute the time step ratio to
  * support a variable time step.
  */
 double _inverseTimestep;

 /**
  * This is for debugging the solver.
  */
 bool _warmStarting;

 /**
  * This is for debugging the solver.
  */
 bool _continuousPhysics;

 List&lt;List&lt;ContactRegister&gt;&gt; _contactStacks;

 /** Pooling */
 final Vector2 center;
 final Vector2 axis;

 final TimeStep timestep;
 final Vector2 cA;
 final Vector2 cB;
 final WorldQueryWrapper wqwrapper;

 final TimeOfImpactInput toiInput;
 final TimeOfImpactOutput toiOutput;
 final Sweep backup;
 final TimeOfImpactSolver toiSolver;
 List&lt;Contact&gt; contacts;
 final Island island;
 List&lt;Body&gt; stack;

 /**
  * Constructs a world object.
  *
  * gravity
  *   the world gravity vector.
  * doSleep
  *   improve performance by not simulating inactive bodies.
  */
 World(Vector2 gravity, bool doSleep, DefaultWorldPool argPool) :
   _pool = argPool,
   _jointDestructionListener = null,
   _fixtureDestructionListener = null,
   _debugDraw = null,

   _bodyList = null,
   _jointList = null,

   _bodyCount = 0,
   _jointCount = 0,

   _warmStarting = true,
   _continuousPhysics = true,

   _allowSleep = doSleep,
   _gravity = gravity,

   _flags = CLEAR_FORCES,

   _inverseTimestep = 0.0,

   _contactStacks = new List&lt;List&lt;ContactRegister&gt;&gt;(ShapeType.TYPE_COUNT),

   // Initialize Pool Objects.
   center = new Vector2.zero(),
   axis = new Vector2.zero(),
   timestep = new TimeStep(),
   cA = new Vector2.zero(),
   cB = new Vector2.zero(),
   wqwrapper = new WorldQueryWrapper(),
   toiInput = new TimeOfImpactInput(),
   toiOutput = new TimeOfImpactOutput(),
   backup = new Sweep(),
   toiSolver = new TimeOfImpactSolver(),
   contacts = new List&lt;Contact&gt;(Settings.MAX_TIME_OF_IMPACT_CONTACTS),
   island = new Island(),
   stack = new List&lt;Body&gt;(10) {

   _contactManager = new ContactManager(this);

   // Initialize settings.
   for (int i = 0; i &lt; _contactStacks.length; i++) {
     _contactStacks[i] = new List&lt;ContactRegister&gt;(ShapeType.TYPE_COUNT);
   }
   _initializeRegisters();
 }

 void _addType(Queue&lt;Contact&gt; creatorStack, int type1, int type2) {
   ContactRegister register = new ContactRegister();
   register.creator = creatorStack;
   register.primary = true;
   _contactStacks[type1][type2] = register;

   if (type1 != type2) {
     ContactRegister register2 = new ContactRegister();
     register2.creator = creatorStack;
     register2.primary = false;
     _contactStacks[type2][type1] = register2;
   }
 }

 void _initializeRegisters() {
   _addType(_pool.getCircleContactStack(), ShapeType.CIRCLE, ShapeType.CIRCLE);
   _addType(_pool.getPolyCircleContactStack(), ShapeType.POLYGON,
       ShapeType.CIRCLE);
   _addType(_pool.getPolyContactStack(), ShapeType.POLYGON, ShapeType.POLYGON);
 }

 Contact popContact(Fixture fixtureA, Fixture fixtureB) {
   int type1 = fixtureA.type;
   int type2 = fixtureB.type;

   ContactRegister reg = _contactStacks[type1][type2];
   Queue&lt;Contact&gt; creator = reg.creator;
   if (creator != null) {

     // Ensure that the creator isn't depleted of contact stacks.
     if (creator.isEmpty) {
       creator = _getFreshContactStack(type1, type2);
     }

     if (reg.primary) {
       Contact c = creator.removeFirst();
       c.init(fixtureA, fixtureB);
       return c;
     } else {
       Contact c = creator.removeFirst();
       c.init(fixtureB, fixtureA);
       return c;
     }
   } else {
     return null;
   }
 }

 /** Returns a newly stocked contact stack of the appropriate type. */
 Queue&lt;Contact&gt; _getFreshContactStack(int type1, int type2) {
   if (type1 == ShapeType.CIRCLE &amp;&amp; type2 == ShapeType.CIRCLE) {
     return _pool.getCircleContactStack();
   } else if (type1 == ShapeType.POLYGON &amp;&amp; type2 == ShapeType.POLYGON) {
     return _pool.getPolyContactStack();
   } else {
     return _pool.getPolyCircleContactStack();
   }
 }

 void pushContact(Contact contact) {
   if (contact.manifold.pointCount &gt; 0) {
     contact.fixtureA.body.awake = true;
     contact.fixtureB.body.awake = true;
   }

   int type1 = contact.fixtureA.type;
   int type2 = contact.fixtureB.type;

   Queue&lt;Contact&gt; creator = _contactStacks[type1][type2].creator;
   creator.addFirst(contact);
 }


 /**
  * Register a contact filter to provide specific control over collision.
  * Otherwise the default filter is used (_defaultFilter). The listener is
  * owned by you and must remain in scope.
  */
 void set contactFilter(ContactFilter filter) {
   _contactManager.contactFilter = filter;
 }

 /**
  * Register a contact event listener. The listener is owned by you and must
  * remain in scope.
  */
 void set contactListener(ContactListener listener) {
   _contactManager.contactListener = listener;
 }

 ContactListener get contactListener =&gt; _contactManager.contactListener;

 /**
  * Register a routine for debug drawing. The debug draw functions are called
  * inside with World.DrawDebugData method. The debug draw object is owned
  * by you and must remain in scope.
  */
 void set debugDraw(DebugDraw debugDraw) {
   _debugDraw = debugDraw;
 }

 /**
  * Create a rigid body given a definition. No reference to the definition
  * is retained.
  */
 Body createBody(BodyDef def) {
   assert (locked == false);
   if (locked) {
     return null;
   }
   Body b = new Body(def, this);

   // add to world doubly linked list
   b.prev = null;
   b.next = _bodyList;
   if (_bodyList != null) {
     _bodyList.prev = b;
   }
   _bodyList = b;
   ++_bodyCount;

   return b;
 }

 /**
  * Create a joint to constrain bodies together. No reference to the definition
  * is retained. This may cause the connected bodies to cease colliding.
  *
  * Warning: This function is locked during callbacks.
  */
 Joint createJoint(JointDef def) {
   assert (locked == false);
   if (locked) {
     return null;
   }

   Joint j = new Joint.create(this, def);

   // Connect to the world list.
   j._prev = null;
   j._next = _jointList;
   if (_jointList != null) _jointList._prev = j;
   _jointList = j;
   ++_jointCount;

   // Connect to the bodies' doubly linked lists.
   j.edgeA.joint = j;
   j.edgeA.other = j.bodyB;
   j.edgeA.prev = null;
   j.edgeA.next = j.bodyA.jointList;
   if (j.bodyA.jointList != null) {
     j.bodyA.jointList.prev = j.edgeA;
   }
   j.bodyA.jointList = j.edgeA;

   j.edgeB.joint = j;
   j.edgeB.other = j.bodyA;
   j.edgeB.prev = null;
   j.edgeB.next = j.bodyB.jointList;
   if (j.bodyB.jointList != null) {
     j.bodyB.jointList.prev = j.edgeB;
   }
   j.bodyB.jointList = j.edgeB;

   Body bodyA = def.bodyA;
   Body bodyB = def.bodyB;

   // If the joint prevents collisions, then flag any contacts for filtering.
   if (def.collideConnected == false) {
     ContactEdge edge = bodyB.contactList;
     while (edge != null) {
       if (edge.other == bodyA) {
         // Flag the contact for filtering at the next time step (where either
         // body is awake).
         edge.contact.flagForFiltering();
       }

       edge = edge.next;
     }
   }

   // Note: creating a joint doesn't wake the bodies.

   return j;
 }

 /**
  * Destroy a joint. This may cause the connected bodies to begin colliding.
  *
  * Warning: This function is locked during callbacks.
  */
 void destroyJoint(Joint joint) {
   assert (locked == false);
   if (locked) {
     return;
   }

   bool collideConnected = joint.collideConnected;

   // Remove from the doubly linked list.
   if (joint._prev != null) joint._prev._next = joint._next;

   if (joint._next != null) joint._next._prev = joint._prev;

   if (joint == _jointList) _jointList = joint._next;

   // Disconnect from island graph.
   Body bodyA = joint.bodyA;
   Body bodyB = joint.bodyB;

   // Wake up connected bodies.
   bodyA.awake = true;
   bodyB.awake = true;

   // Remove from body 1.
   if (joint.edgeA.prev != null) {
     joint.edgeA.prev.next = joint.edgeA.next;
   }

   if (joint.edgeA.next != null) {
     joint.edgeA.next.prev = joint.edgeA.prev;
   }

   if (joint.edgeA == bodyA.jointList) {
     bodyA.jointList = joint.edgeA.next;
   }

   joint.edgeA.prev = null;
   joint.edgeA.next = null;

   // Remove from body 2
   if (joint.edgeB.prev != null) {
     joint.edgeB.prev.next = joint.edgeB.next;
   }

   if (joint.edgeB.next != null) {
     joint.edgeB.next.prev = joint.edgeB.prev;
   }

   if (joint.edgeB == bodyB.jointList) {
     bodyB.jointList = joint.edgeB.next;
   }

   joint.edgeB.prev = null;
   joint.edgeB.next = null;

   Joint.destroy(joint);

   assert (_jointCount &gt; 0);
   --_jointCount;

   // If the joint prevents collisions, then flag any contacts for filtering.
   if (collideConnected == false) {
     ContactEdge edge = bodyB.contactList;
     while (edge != null) {
       if (edge.other == bodyA) {
         // Flag the contact for filtering at the next time step (where either
         // body is awake).
         edge.contact.flagForFiltering();
       }

       edge = edge.next;
     }
   }
 }

 /**
  * Destroy a rigid body given a definition. No reference to the definition
  * is retained. This function is locked during callbacks.
  *
  * warning: This automatically deletes all associated shapes.
  * warning: This function is locked during callbacks.
  */
 void destroyBody(Body body) {
   assert (_bodyCount &gt; 0);
   assert (locked == false);
   if (locked) {
     return;
   }

   // Delete the attached joints.
   JointEdge je = body.jointList;
   while (je != null) {
     JointEdge je0 = je;
     je = je.next;
     if (_jointDestructionListener != null) {
       _jointDestructionListener(je0.joint);
     }

     destroyJoint(je0.joint);
   }
   body.jointList = null;

   // Delete the attached contacts.
   ContactEdge ce = body.contactList;
   while (ce != null) {
     ContactEdge ce0 = ce;
     ce = ce.next;
     _contactManager.destroy(ce0.contact);
   }
   body.contactList = null;

   Fixture f = body.fixtureList;
   while (f != null) {
     Fixture f0 = f;
     f = f.next;

     if (_fixtureDestructionListener != null) {
       _fixtureDestructionListener(f0);
     }

     f0.destroyProxy(_contactManager.broadPhase);
     f0.destroy();
     // TODO djm recycle fixtures (here or in that destroy method)
   }
   body.fixtureList = null;
   body.fixtureCount = 0;

   // Remove world body list.
   if (body.prev != null) {
     body.prev.next = body.next;
   }

   if (body.next != null) {
     body.next.prev = body.prev;
   }

   if (body == _bodyList) {
     _bodyList = body.next;
   }

   --_bodyCount;
 }

 /**
  * Take a time step. This performs collision detection, integration,
  * and constraint solution.
  *
  * param timeStep
  *   the amount of time to simulate, this should not vary.
  * param velocityIterations
  *   for the velocity constraint solver.
  * param positionIterations
  *   for the position constraint solver.
  */
 void step(double dt, int velocityIterations, int positionIterations) {

   // If new fixtures were added, we need to find the new contacts.
   if ((_flags &amp; NEW_FIXTURE) == NEW_FIXTURE) {
     _contactManager.findNewContacts();
     _flags &amp;= ~NEW_FIXTURE;
   }

   _flags |= LOCKED;

   timestep.dt = dt;
   timestep.velocityIterations = velocityIterations;
   timestep.positionIterations = positionIterations;
   if (dt &gt; 0.0) {
     timestep.inv_dt = 1.0 / dt;
   } else {
     timestep.inv_dt = 0.0;
   }

   timestep.dtRatio = _inverseTimestep * dt;
   timestep.warmStarting = _warmStarting;

   // Update contacts. This is where some contacts are destroyed.
   _contactManager.collide();

   // Integrate velocities, solve velocity constraints, and integrate
   // positions.
   if (timestep.dt &gt; 0.0) {
     solve(timestep);
     if (_continuousPhysics) {
       solveTimeOfImpact();
     }
     _inverseTimestep = timestep.inv_dt;
   }

   if ((_flags &amp; CLEAR_FORCES) == CLEAR_FORCES) {
     clearForces();
   }

   _flags &amp;= ~LOCKED;
 }

 /**
  * Call this after you are done with time steps to clear the forces.
  * You normally call this after each call to Step, unless you are
  * performing sub-steps. By default, forces will be automatically cleared,
  * so you don't need to call this function.
  *
  * see setAutoClearForces
  */
 void clearForces() {
   for (Body body = _bodyList; body != null; body = body.next) {
     body._force.setZero();
     body._torque = 0.0;
   }
 }

 /**
  * Call this to draw shapes and other debug draw data.
  */
 void drawDebugData() {
   if (_debugDraw == null) {
     return;
   }

   final int drawFlags = _debugDraw.flags;

   if ((drawFlags &amp; DebugDraw.e_shapeBit) == DebugDraw.e_shapeBit) {
     Transform xf = new Transform();
     Color3 color = new Color3();
     for (Body b = _bodyList; b != null; b = b.next) {
       xf.setFrom(b.originTransform);
       for (Fixture f = b.fixtureList; f != null; f = f.next) {
         if (b.active == false) {
           color.setFromRGBF(0.5, 0.5, 0.3);
           drawShape(f, xf, color);
         } else if (b.type == BodyType.STATIC) {
           color.setFromRGBF(0.5, 0.9, 0.3);
           drawShape(f, xf, color);
         } else if (b.type == BodyType.KINEMATIC) {
           color.setFromRGBF(0.5, 0.5, 0.9);
           drawShape(f, xf, color);
         } else if (b.awake == false) {
           color.setFromRGBF(0.9, 0.9, 0.9);
           drawShape(f, xf, color);
         } else {
           color.setFromRGBF(0.9, 0.7, 0.7);
           drawShape(f, xf, color);
         }
       }
     }
   }

   if ((drawFlags &amp; DebugDraw.e_jointBit) == DebugDraw.e_jointBit) {
     for (Joint j = _jointList; j != null; j = j._next)
       drawJoint(j);
   }

   if ((drawFlags &amp; DebugDraw.e_pairBit) == DebugDraw.e_pairBit) {
     Color3 color = new Color3.fromRGBF(0.3, 0.9, 0.9);
     for (Contact c = _contactManager.contactList; c != null; c = c.next) {
       Fixture fixtureA = c.fixtureA;
       Fixture fixtureB = c.fixtureB;

       cA.setFrom(fixtureA.box.center);
       cB.setFrom(fixtureB.box.center);

       _debugDraw.drawSegment(cA, cB, color);
     }
   }

   if ((drawFlags &amp; DebugDraw.e_aabbBit) == DebugDraw.e_aabbBit) {
     Color3 color = new Color3.fromRGBF(0.9, 0.3, 0.9);

     for (Body b = _bodyList; b != null; b = b.next) {
       if (!b.active) {
         continue;
       }

       for (Fixture f = b.fixtureList; f != null; f = f.next) {
         AxisAlignedBox aabb = f.proxy.box;

         List&lt;Vector2&gt; vs = new List&lt;Vector2&gt;(4);
         for (int i = 0; i &lt; vs.length; i++) {
           vs[i] = new Vector2.zero();
         }

         vs[0].setValues(aabb.lowerBound.x, aabb.lowerBound.y);
         vs[1].setValues(aabb.upperBound.x, aabb.lowerBound.y);
         vs[2].setValues(aabb.upperBound.x, aabb.upperBound.y);
         vs[3].setValues(aabb.lowerBound.x, aabb.upperBound.y);

         if (0 != (drawFlags &amp; DebugDraw.e_lineDrawingBit)) {
           _debugDraw.drawPolygon(vs, 4, color);
         } else {
           _debugDraw.drawSolidPolygon(vs, 4, color);
         }
       }
     }
   }

   if ((drawFlags &amp; DebugDraw.e_centerOfMassBit) ==
       DebugDraw.e_centerOfMassBit) {
     Transform xf = new Transform();
     final Color3 color = new Color3.fromRGB(1, 0, 0);
     for (Body b = _bodyList; b != null; b = b.next) {
       xf.setFrom(b.originTransform);
       xf.position.setFrom(b.worldCenter);
       _debugDraw.drawTransform(xf, color);
     }
   }
 }

 /**
  * Query the world for all fixtures that potentially overlap the
  * provided AABB.
  *
  * param callback
  *   a user implemented callback class.
  * param aabb
  *   the query box.
  */
 void queryAABB(QueryCallback callback, AxisAlignedBox aabb) {
   wqwrapper.broadPhase = _contactManager.broadPhase;
   wqwrapper.callback = callback;
   _contactManager.broadPhase.query(wqwrapper, aabb);
 }

 /**
  * Get the world contact list. With the returned contact, use Contact.getNext
  * to get the next contact in the world list. A null contact indicates the
  * end of the list.
  *
  * return the head of the world contact list.
  * warning contacts are
  */
 Contact get contactList =&gt; _contactManager.contactList;

 /**
  * Get the number of broad-phase proxies.
  */
 int get proxyCount =&gt; _contactManager.broadPhase.proxyCount;

 /**
  * Get the number of contacts (each may have 0 or more contact points).
  */
 int get contactCount =&gt; _contactManager.contactCount;

 /**
  * Is the world locked (in the middle of a time step).
  */
 bool get locked =&gt; (_flags &amp; LOCKED) == LOCKED;

 /**
  * Set flag to control automatic clearing of forces after each time step.
  */
 void set autoClearForces(bool flag) {
   if (flag) {
     _flags |= CLEAR_FORCES;
   } else {
     _flags &amp;= ~CLEAR_FORCES;
   }
 }

 Body get bodyList =&gt; _bodyList;

 Joint get jointList =&gt; _jointList;

 int get jointCount =&gt; _jointCount;

 /**
  * Get the flag that controls automatic clearing of forces after each time
  * step.
  */
 bool get autoClearForces =&gt; (_flags &amp; CLEAR_FORCES) == CLEAR_FORCES;

 void solve(TimeStep timeStep) {
   // Size the  for the worst case.
   island.init(_bodyCount, _contactManager.contactCount, _jointCount,
       _contactManager.contactListener);

   // Clear all the island flags.
   for (Body b = _bodyList; b != null; b = b.next) {
     b.flags &amp;= ~Body.ISLAND_FLAG;
   }
   for (Contact c = _contactManager.contactList; c != null; c = c.next) {
     c.flags &amp;= ~Contact.ISLAND_FLAG;
   }
   for (Joint j = jointList; j != null; j = j._next) {
     j.islandFlag = false;
   }

   // Build and simulate all awake islands.
   int stackSize = _bodyCount;
   if (stack.length &lt; stackSize) {
     stack = new List&lt;Body&gt;(stackSize);
   }

   for (Body seed = _bodyList; seed != null; seed = seed.next) {
     if ((seed.flags &amp; Body.ISLAND_FLAG) == Body.ISLAND_FLAG) {
       continue;
     }

     if (seed.awake == false || seed.active == false) {
       continue;
     }

     // The seed can be dynamic or kinematic.
     if (seed.type == BodyType.STATIC) {
       continue;
     }

     // Reset island and stack.
     island.clear();
     int stackCount = 0;
     stack[stackCount++] = seed;
     seed.flags |= Body.ISLAND_FLAG;

     // Perform a depth first search (DFS) on the constraint graph.
     while (stackCount &gt; 0) {
       // Grab the next body off the stack and add it to the island.
       Body b = stack[--stackCount];
       assert (b.active);
       island.addBody(b);

       // Make sure the body is awake.
       b.awake = true;

       // To keep islands as small as possible, we don't
       // propagate islands across static bodies.
       if (b.type == BodyType.STATIC) {
         continue;
       }

       // Search all contacts connected to this body.
       for (ContactEdge ce = b.contactList; ce != null; ce = ce.next) {
         Contact contact = ce.contact;

         // Has this contact already been added to an island?
         if ((contact.flags &amp; Contact.ISLAND_FLAG) == Contact.ISLAND_FLAG) {
           continue;
         }

         // Is this contact solid and touching?
         if (contact.enabled == false || contact.touching == false) {
           continue;
         }

         // Skip sensors.
         bool sensorA = contact.fixtureA.isSensor;
         bool sensorB = contact.fixtureB.isSensor;
         if (sensorA || sensorB) {
           continue;
         }

         island.addContact(contact);
         contact.flags |= Contact.ISLAND_FLAG;

         Body other = ce.other;

         // Was the other body already added to this island?
         if ((other.flags &amp; Body.ISLAND_FLAG) == Body.ISLAND_FLAG) {
           continue;
         }

         assert (stackCount &lt; stackSize);
         stack[stackCount++] = other;
         other.flags |= Body.ISLAND_FLAG;
       }

       // Search all joints connect to this body.
       for (JointEdge je = b.jointList; je != null; je = je.next) {
         if (je.joint.islandFlag == true) {
           continue;
         }

         Body other = je.other;

         // Don't simulate joints connected to inactive bodies.
         if (other.active == false) {
           continue;
         }

         island.addJoint(je.joint);
         je.joint.islandFlag = true;

         if (((other.flags &amp; Body.ISLAND_FLAG) == Body.ISLAND_FLAG)) {
           continue;
         }

         assert (stackCount &lt; stackSize);
         stack[stackCount++] = other;
         other.flags |= Body.ISLAND_FLAG;
       }
     }

     island.solve(timeStep, _gravity, _allowSleep);

     // Post solve cleanup.
     for (int i = 0; i &lt; island.bodyCount; ++i) {
       // Allow static bodies to participate in other islands.
       Body b = island.bodies[i];
       if (b.type == BodyType.STATIC) {
         b.flags &amp;= ~Body.ISLAND_FLAG;
       }
     }
   }

   // Synchronize fixtures, check for out of range bodies.
   for (Body b = _bodyList; b != null; b = b.next) {
     // If a body was not in an island then it did not move.
     if ((b.flags &amp; Body.ISLAND_FLAG) == 0) {
       continue;
     }

     if (b.type == BodyType.STATIC) {
       continue;
     }

     // Update fixtures (for broad-phase).
     b.synchronizeFixtures();
   }

   // Look for new contacts.
   _contactManager.findNewContacts();
 }

 void solveTimeOfImpact() {
   // Prepare all contacts.
   for (Contact c = _contactManager.contactList; c != null; c = c.next) {
     // Enable the contact
     c.flags |= Contact.ENABLED_FLAG;

     // Set the number of TimeOfImpact events for this contact to zero.
     c.toiCount = 0;
   }

   // Initialize the TimeOfImpact flag.
   for (Body body = _bodyList; body != null; body = body.next) {
     // Kinematic, and static bodies will not be affected by the TimeOfImpact
     // event.  If a body was not in an island then it did not move.
     if ((body.flags &amp; Body.ISLAND_FLAG) == 0 ||
         body.type == BodyType.KINEMATIC ||
         body.type == BodyType.STATIC) {
       body.flags |= Body.TO_I_FLAG;
     } else {
       body.flags &amp;= ~Body.TO_I_FLAG;
     }
   }

   // Collide non-bullets.
   for (Body body = _bodyList; body != null; body = body.next) {
     if ((body.flags &amp; Body.TO_I_FLAG) == Body.TO_I_FLAG ||
         body.bullet == true) {
       continue;
     }

     solveTimeOfImpactGivenBody(body);

     body.flags |= Body.TO_I_FLAG;
   }

   // Collide bullets.
   for (Body body = _bodyList; body != null; body = body.next) {
     if ((body.flags &amp; Body.TO_I_FLAG) == Body.TO_I_FLAG ||
         !body.bullet) {
       continue;
     }

     solveTimeOfImpactGivenBody(body);

     body.flags |= Body.TO_I_FLAG;
   }
 }

 void solveTimeOfImpactGivenBody(Body body) {
   // Find the minimum contact.
   Contact toiContact = null;
   num toi = 1.0;
   Body toiOther = null;
   bool found;
   int count;
   int iter = 0;

   bool bullet = body.bullet;

   // Iterate until all contacts agree on the minimum TimeOfImpact. We have
   // to iterate because the TimeOfImpact algorithm may skip some intermediate
   // collisions when objects rotate through each other.
   do {
     count = 0;
     found = false;
     for (ContactEdge ce = body.contactList; ce != null; ce = ce.next) {
       if (ce.contact == toiContact) {
         continue;
       }

       Body other = ce.other;
       int type = other.type;

       // Only bullets perform TimeOfImpact with dynamic bodies.
       if (bullet) {
         // Bullets only perform TimeOfImpact with bodies that have their
         // TimeOfImpact resolved.
         if ((other.flags &amp; Body.TO_I_FLAG) == 0) {
           continue;
         }

         // No repeated hits on non-static bodies
         if (type != BodyType.STATIC &amp;&amp;
             (ce.contact.flags &amp; Contact.BULLET_HIT_FLAG) != 0) {
           continue;
         }
       } else if (type == BodyType.DYNAMIC) {
         continue;
       }

       // Check for a disabled contact.
       // Prevent infinite looping.
       Contact contact = ce.contact;
       if (!contact.enabled || contact.toiCount &gt; 10) {
         continue;
       }

       Fixture fixtureA = contact.fixtureA;
       Fixture fixtureB = contact.fixtureB;

       // Cull sensors.
       if (fixtureA.isSensor || fixtureB.isSensor) {
         continue;
       }

       Body bodyA = fixtureA.body;
       Body bodyB = fixtureB.body;

       // Compute the time of impact in interval [0, minTimeOfImpact]
       toiInput.proxyA.setFromShape(fixtureA.shape);
       toiInput.proxyB.setFromShape(fixtureB.shape);
       toiInput.sweepA.setFrom(bodyA.sweep);
       toiInput.sweepB.setFrom(bodyB.sweep);
       toiInput.tMax = toi;

       _pool.timeOfImpact.timeOfImpact(toiOutput, toiInput);

       if (toiOutput.state == TimeOfImpactOutputState.TOUCHING &amp;&amp;
           toiOutput.t &lt; toi) {
         toiContact = contact;
         toi = toiOutput.t;
         toiOther = other;
         found = true;
       }

       ++count;
     }

     ++iter;
   } while (found &amp;&amp; count &gt; 1 &amp;&amp; iter &lt; 50);

   if (toiContact == null) {
     body.advance(1.0);
     return;
   }

   backup.setFrom(body.sweep);
   body.advance(toi);
   toiContact.update(_contactManager.contactListener);
   if (toiContact.enabled == false) {
     // Contact disabled. Backup and recurse.
     body.sweep.setFrom(backup);
     solveTimeOfImpactGivenBody(body);
   }

   ++toiContact.toiCount;

   // Update all the valid contacts on this body and build a contact island.
   if (contacts == null ||
       contacts.length &lt; Settings.MAX_TIME_OF_IMPACT_CONTACTS) {
     contacts = new List&lt;Contact&gt;(Settings.MAX_TIME_OF_IMPACT_CONTACTS);
   }

   count = 0;
   for (ContactEdge ce = body.contactList; ce != null &amp;&amp;
        count &lt; Settings.MAX_TIME_OF_IMPACT_CONTACTS;
        ce = ce.next) {
     Body other = ce.other;
     int type = other.type;

     // Only perform correction with static bodies, so the
     // body won't get pushed out of the world.
     if (type == BodyType.DYNAMIC) {
       continue;
     }

     // Check for a disabled contact.
     Contact contact = ce.contact;
     if (!contact.enabled) {
       continue;
     }

     Fixture fixtureA = contact.fixtureA;
     Fixture fixtureB = contact.fixtureB;

     // Cull sensors.
     if (fixtureA.isSensor || fixtureB.isSensor) {
       continue;
     }

     // The contact likely has some new contact points. The listener
     // gives the user a chance to disable the contact.
     if (contact != toiContact) {
       contact.update(_contactManager.contactListener);
     }

     // Did the user disable the contact?
     if (!contact.enabled || !contact.touching) {
       continue;
     }

     contacts[count] = contact;
     ++count;
   }

   // Reduce the TimeOfImpact body's overlap with the contact island.
   toiSolver.initialize(contacts, count, body);

   num k_toiBaumgarte = 0.75;
   // bool solved = false;
   for (int i = 0; i &lt; 20; ++i) {
     if (toiSolver.solve(k_toiBaumgarte)) {
       // solved = true;
       break;
     }
   }

   if (toiOther.type != BodyType.STATIC) {
     toiContact.flags |= Contact.BULLET_HIT_FLAG;
   }
 }

 void drawShape(Fixture fixture, Transform xf, Color3 color) {
   switch (fixture.type) {
     case ShapeType.CIRCLE:
       final CircleShape circle = fixture.shape;

       // Vector2 center = Mul(xf, circle.p);
       Transform.mulToOut(xf, circle.position, center);
       num radius = circle.radius;
       axis.setValues(xf.rotation.entry(0,0), xf.rotation.entry(1,0));

       if (0 != (_debugDraw.flags &amp; DebugDraw.e_lineDrawingBit)) {
         _debugDraw.drawCircle(center, radius, color, axis);
       } else {
         _debugDraw.drawSolidCircle(center, radius, color, axis);
       }
       break;

     case ShapeType.POLYGON:
       final PolygonShape poly = fixture.shape;
       int vertexCount = poly.vertexCount;
       assert (vertexCount &lt;= Settings.MAX_POLYGON_VERTICES);
       List&lt;Vector2&gt; vertices = new List&lt;Vector2&gt;.generate(
           vertexCount, (i) =&gt; new Vector2.zero());

       for (int i = 0; i &lt; vertexCount; ++i) {
         assert(poly.vertices[i] != null);
         assert(vertices[i] != null);
         Transform.mulToOut(xf, poly.vertices[i], vertices[i]);
       }

       if (0 != (_debugDraw.flags &amp; DebugDraw.e_lineDrawingBit)) {
         _debugDraw.drawPolygon(vertices, vertexCount, color);
       } else if (vertexCount &gt; 2) {
         _debugDraw.drawSolidPolygon(vertices, vertexCount, color);
       } else {
         _debugDraw.drawPolygon(vertices, vertexCount, color);
       }
       break;
   }
 }

 /** Draws a joint for debugging purposes. */
 //TODO(gregbglw): Draw more types of joints.
 void drawJoint(Joint joint) {
   Body bodyA = joint.bodyA;
   Body bodyB = joint.bodyB;
   Transform xf1 = bodyA.originTransform;
   Transform xf2 = bodyB.originTransform;
   Vector2 x1 = new Vector2.copy(xf1.position);
   Vector2 x2 = new Vector2.copy(xf2.position);
   Vector2 p1 = new Vector2.zero();
   Vector2 p2 = new Vector2.zero();
   joint.getAnchorA(p1);
   joint.getAnchorB(p2);

   // Set the drawing color.
   Color3 color = new Color3.fromRGBF(0.5, 0.3, 0.3);

   switch (joint.type) {
     case JointType.DISTANCE :
       _debugDraw.drawSegment(p1, p2, color);
       break;

     case JointType.PULLEY :
       throw new UnimplementedError();
       //Vector2 s1 = pulley.getGroundAnchorA();
       //Vector2 s2 = pulley.getGroundAnchorB();
       //_debugDraw.drawSegment(s1, p1, color);
       //_debugDraw.drawSegment(s2, p2, color);
       //_debugDraw.drawSegment(s1, s2, color);
       //break;

     case JointType.FRICTION:
       _debugDraw.drawSegment(x1, x2, color);
       break;

     case JointType.CONSTANT_VOLUME :
       // Nothing to see here.
     case JointType.MOUSE :
       // Don't draw anything for mouse. Already have cursor!
       break;
     default :
       Vector2 p1t = new Vector2.copy(p1); // copies since drawSegment modifies
       Vector2 p2t = new Vector2.copy(p2);
       _debugDraw.drawSegment(x1, p1, color);
       _debugDraw.drawSegment(p1t, p2, color);
       _debugDraw.drawSegment(x2, p2t, color);
       break;
   }
 }
}
</pre>
</div>
<div>
<h3>Static Properties</h3>
<div class="field"><h4 id="CLEAR_FORCES">
<button class="show-code">Code</button>
const <a href="http://api.dartlang.org/dart_core/int.html">int</a>         <strong>CLEAR_FORCES</strong> <a class="anchor-link"
            href="#CLEAR_FORCES"
            title="Permalink to World.CLEAR_FORCES">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static const int CLEAR_FORCES = 0x0004
</pre>
</div>
</div>
<div class="field"><h4 id="LOCKED">
<button class="show-code">Code</button>
const <a href="http://api.dartlang.org/dart_core/int.html">int</a>         <strong>LOCKED</strong> <a class="anchor-link"
            href="#LOCKED"
            title="Permalink to World.LOCKED">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static const int LOCKED = 0x0002
</pre>
</div>
</div>
<div class="field"><h4 id="NEW_FIXTURE">
<button class="show-code">Code</button>
const <a href="http://api.dartlang.org/dart_core/int.html">int</a>         <strong>NEW_FIXTURE</strong> <a class="anchor-link"
            href="#NEW_FIXTURE"
            title="Permalink to World.NEW_FIXTURE">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static const int NEW_FIXTURE = 0x0001
</pre>
</div>
</div>
<div class="field"><h4 id="WORLD_POOL_CONTAINER_SIZE">
<button class="show-code">Code</button>
const <a href="http://api.dartlang.org/dart_core/int.html">int</a>         <strong>WORLD_POOL_CONTAINER_SIZE</strong> <a class="anchor-link"
            href="#WORLD_POOL_CONTAINER_SIZE"
            title="Permalink to World.WORLD_POOL_CONTAINER_SIZE">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static const int WORLD_POOL_CONTAINER_SIZE = 10
</pre>
</div>
</div>
<div class="field"><h4 id="WORLD_POOL_SIZE">
<button class="show-code">Code</button>
const <a href="http://api.dartlang.org/dart_core/int.html">int</a>         <strong>WORLD_POOL_SIZE</strong> <a class="anchor-link"
            href="#WORLD_POOL_SIZE"
            title="Permalink to World.WORLD_POOL_SIZE">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static const int WORLD_POOL_SIZE = 100
</pre>
</div>
</div>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="World">
<button class="show-code">Code</button>
new <strong>World</strong>(<a href="../vector_math/Vector2.html">Vector2</a> gravity, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> doSleep, <a href="../box2d/DefaultWorldPool.html">DefaultWorldPool</a> argPool) <a class="anchor-link" href="#World"
              title="Permalink to World.World">#</a></h4>
<div class="doc">
<p>Constructs a world object.</p>
<p>gravity
  the world gravity vector.
doSleep
  improve performance by not simulating inactive bodies.</p>
<pre class="source">
World(Vector2 gravity, bool doSleep, DefaultWorldPool argPool) :
 _pool = argPool,
 _jointDestructionListener = null,
 _fixtureDestructionListener = null,
 _debugDraw = null,

 _bodyList = null,
 _jointList = null,

 _bodyCount = 0,
 _jointCount = 0,

 _warmStarting = true,
 _continuousPhysics = true,

 _allowSleep = doSleep,
 _gravity = gravity,

 _flags = CLEAR_FORCES,

 _inverseTimestep = 0.0,

 _contactStacks = new List&lt;List&lt;ContactRegister&gt;&gt;(ShapeType.TYPE_COUNT),

 // Initialize Pool Objects.
 center = new Vector2.zero(),
 axis = new Vector2.zero(),
 timestep = new TimeStep(),
 cA = new Vector2.zero(),
 cB = new Vector2.zero(),
 wqwrapper = new WorldQueryWrapper(),
 toiInput = new TimeOfImpactInput(),
 toiOutput = new TimeOfImpactOutput(),
 backup = new Sweep(),
 toiSolver = new TimeOfImpactSolver(),
 contacts = new List&lt;Contact&gt;(Settings.MAX_TIME_OF_IMPACT_CONTACTS),
 island = new Island(),
 stack = new List&lt;Body&gt;(10) {

 _contactManager = new ContactManager(this);

 // Initialize settings.
 for (int i = 0; i &lt; _contactStacks.length; i++) {
   _contactStacks[i] = new List&lt;ContactRegister&gt;(ShapeType.TYPE_COUNT);
 }
 _initializeRegisters();
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="method"><h4 id="autoClearForces">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> <strong>get autoClearForces</strong> <a class="anchor-link" href="#autoClearForces"
              title="Permalink to World.get autoClearForces">#</a></h4>
<div class="doc">
<p>Get the flag that controls automatic clearing of forces after each time
step.</p>
<pre class="source">
bool get autoClearForces =&gt; (_flags &amp; CLEAR_FORCES) == CLEAR_FORCES;
</pre>
</div>
</div>
<div class="method"><h4 id="autoClearForces=">
<button class="show-code">Code</button>
void <strong>set autoClearForces</strong>(<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> flag) <a class="anchor-link" href="#autoClearForces="
              title="Permalink to World.set autoClearForces">#</a></h4>
<div class="doc">
<p>Set flag to control automatic clearing of forces after each time step.</p>
<pre class="source">
void set autoClearForces(bool flag) {
 if (flag) {
   _flags |= CLEAR_FORCES;
 } else {
   _flags &amp;= ~CLEAR_FORCES;
 }
}
</pre>
</div>
</div>
<div class="field"><h4 id="axis">
<button class="show-code">Code</button>
final <a href="../vector_math/Vector2.html">Vector2</a>         <strong>axis</strong> <a class="anchor-link"
            href="#axis"
            title="Permalink to World.axis">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final Vector2 axis
</pre>
</div>
</div>
<div class="field"><h4 id="backup">
<button class="show-code">Code</button>
final <a href="../box2d/Sweep.html">Sweep</a>         <strong>backup</strong> <a class="anchor-link"
            href="#backup"
            title="Permalink to World.backup">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final Sweep backup
</pre>
</div>
</div>
<div class="field"><h4 id="bodyList">
<button class="show-code">Code</button>
final <a href="../box2d/Body.html">Body</a>         <strong>bodyList</strong> <a class="anchor-link"
            href="#bodyList"
            title="Permalink to World.bodyList">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Body get bodyList =&gt; _bodyList;
</pre>
</div>
</div>
<div class="field"><h4 id="cA">
<button class="show-code">Code</button>
final <a href="../vector_math/Vector2.html">Vector2</a>         <strong>cA</strong> <a class="anchor-link"
            href="#cA"
            title="Permalink to World.cA">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final Vector2 cA
</pre>
</div>
</div>
<div class="field"><h4 id="cB">
<button class="show-code">Code</button>
final <a href="../vector_math/Vector2.html">Vector2</a>         <strong>cB</strong> <a class="anchor-link"
            href="#cB"
            title="Permalink to World.cB">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final Vector2 cB
</pre>
</div>
</div>
<div class="field"><h4 id="center">
<button class="show-code">Code</button>
final <a href="../vector_math/Vector2.html">Vector2</a>         <strong>center</strong> <a class="anchor-link"
            href="#center"
            title="Permalink to World.center">#</a>
        </h4>
        <div class="doc">
<p>Pooling </p>
<pre class="source">
final Vector2 center
</pre>
</div>
</div>
<div class="field"><h4 id="contactCount">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/int.html">int</a>         <strong>contactCount</strong> <a class="anchor-link"
            href="#contactCount"
            title="Permalink to World.contactCount">#</a>
        </h4>
        <div class="doc">
<p>Get the number of contacts (each may have 0 or more contact points).</p>
<pre class="source">
int get contactCount =&gt; _contactManager.contactCount;
</pre>
</div>
</div>
<div class="method"><h4 id="contactFilter=">
<button class="show-code">Code</button>
void <strong>set contactFilter</strong>(<a href="../box2d/ContactFilter.html">ContactFilter</a> filter) <a class="anchor-link" href="#contactFilter="
              title="Permalink to World.set contactFilter">#</a></h4>
<div class="doc">
<p>Register a contact filter to provide specific control over collision.
Otherwise the default filter is used (_defaultFilter). The listener is
owned by you and must remain in scope.</p>
<pre class="source">
void set contactFilter(ContactFilter filter) {
 _contactManager.contactFilter = filter;
}
</pre>
</div>
</div>
<div class="field"><h4 id="contactList">
<button class="show-code">Code</button>
final <a href="../box2d/Contact.html">Contact</a>         <strong>contactList</strong> <a class="anchor-link"
            href="#contactList"
            title="Permalink to World.contactList">#</a>
        </h4>
        <div class="doc">
<p>Get the world contact list. With the returned contact, use Contact.getNext
to get the next contact in the world list. A null contact indicates the
end of the list.</p>
<p>return the head of the world contact list.
warning contacts are</p>
<pre class="source">
Contact get contactList =&gt; _contactManager.contactList;
</pre>
</div>
</div>
<div class="field"><h4 id="contactListener">
<button class="show-code">Code</button>
<a href="../box2d/ContactListener.html">ContactListener</a>         <strong>contactListener</strong> <a class="anchor-link"
            href="#contactListener"
            title="Permalink to World.contactListener">#</a>
        </h4>
        <div class="doc">
<p>Register a contact event listener. The listener is owned by you and must
remain in scope.</p>
<pre class="source">
ContactListener get contactListener =&gt; _contactManager.contactListener;
</pre>
<pre class="source">
void set contactListener(ContactListener listener) {
 _contactManager.contactListener = listener;
}
</pre>
</div>
</div>
<div class="field"><h4 id="contacts">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="../box2d/Contact.html">Contact</a>&gt;         <strong>contacts</strong> <a class="anchor-link"
            href="#contacts"
            title="Permalink to World.contacts">#</a>
        </h4>
        <div class="doc">
<pre class="source">
List&lt;Contact&gt; contacts
</pre>
</div>
</div>
<div class="method"><h4 id="debugDraw=">
<button class="show-code">Code</button>
void <strong>set debugDraw</strong>(<a href="../box2d/DebugDraw.html">DebugDraw</a> debugDraw) <a class="anchor-link" href="#debugDraw="
              title="Permalink to World.set debugDraw">#</a></h4>
<div class="doc">
<p>Register a routine for debug drawing. The debug draw functions are called
inside with World.DrawDebugData method. The debug draw object is owned
by you and must remain in scope.</p>
<pre class="source">
void set debugDraw(DebugDraw debugDraw) {
 _debugDraw = debugDraw;
}
</pre>
</div>
</div>
<div class="field"><h4 id="island">
<button class="show-code">Code</button>
final <a href="../box2d/Island.html">Island</a>         <strong>island</strong> <a class="anchor-link"
            href="#island"
            title="Permalink to World.island">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final Island island
</pre>
</div>
</div>
<div class="field"><h4 id="jointCount">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/int.html">int</a>         <strong>jointCount</strong> <a class="anchor-link"
            href="#jointCount"
            title="Permalink to World.jointCount">#</a>
        </h4>
        <div class="doc">
<pre class="source">
int get jointCount =&gt; _jointCount;
</pre>
</div>
</div>
<div class="field"><h4 id="jointList">
<button class="show-code">Code</button>
final <a href="../box2d/Joint.html">Joint</a>         <strong>jointList</strong> <a class="anchor-link"
            href="#jointList"
            title="Permalink to World.jointList">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Joint get jointList =&gt; _jointList;
</pre>
</div>
</div>
<div class="field"><h4 id="locked">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>locked</strong> <a class="anchor-link"
            href="#locked"
            title="Permalink to World.locked">#</a>
        </h4>
        <div class="doc">
<p>Is the world locked (in the middle of a time step).</p>
<pre class="source">
bool get locked =&gt; (_flags &amp; LOCKED) == LOCKED;
</pre>
</div>
</div>
<div class="field"><h4 id="proxyCount">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/int.html">int</a>         <strong>proxyCount</strong> <a class="anchor-link"
            href="#proxyCount"
            title="Permalink to World.proxyCount">#</a>
        </h4>
        <div class="doc">
<p>Get the number of broad-phase proxies.</p>
<pre class="source">
int get proxyCount =&gt; _contactManager.broadPhase.proxyCount;
</pre>
</div>
</div>
<div class="field"><h4 id="stack">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="../box2d/Body.html">Body</a>&gt;         <strong>stack</strong> <a class="anchor-link"
            href="#stack"
            title="Permalink to World.stack">#</a>
        </h4>
        <div class="doc">
<pre class="source">
List&lt;Body&gt; stack
</pre>
</div>
</div>
<div class="field"><h4 id="timestep">
<button class="show-code">Code</button>
final <a href="../box2d/TimeStep.html">TimeStep</a>         <strong>timestep</strong> <a class="anchor-link"
            href="#timestep"
            title="Permalink to World.timestep">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final TimeStep timestep
</pre>
</div>
</div>
<div class="field"><h4 id="toiInput">
<button class="show-code">Code</button>
final <a href="../box2d/TimeOfImpactInput.html">TimeOfImpactInput</a>         <strong>toiInput</strong> <a class="anchor-link"
            href="#toiInput"
            title="Permalink to World.toiInput">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final TimeOfImpactInput toiInput
</pre>
</div>
</div>
<div class="field"><h4 id="toiOutput">
<button class="show-code">Code</button>
final <a href="../box2d/TimeOfImpactOutput.html">TimeOfImpactOutput</a>         <strong>toiOutput</strong> <a class="anchor-link"
            href="#toiOutput"
            title="Permalink to World.toiOutput">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final TimeOfImpactOutput toiOutput
</pre>
</div>
</div>
<div class="field"><h4 id="toiSolver">
<button class="show-code">Code</button>
final <a href="../box2d/TimeOfImpactSolver.html">TimeOfImpactSolver</a>         <strong>toiSolver</strong> <a class="anchor-link"
            href="#toiSolver"
            title="Permalink to World.toiSolver">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final TimeOfImpactSolver toiSolver
</pre>
</div>
</div>
<div class="field"><h4 id="wqwrapper">
<button class="show-code">Code</button>
final <a href="../box2d/WorldQueryWrapper.html">WorldQueryWrapper</a>         <strong>wqwrapper</strong> <a class="anchor-link"
            href="#wqwrapper"
            title="Permalink to World.wqwrapper">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final WorldQueryWrapper wqwrapper
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="clearForces">
<button class="show-code">Code</button>
void <strong>clearForces</strong>() <a class="anchor-link" href="#clearForces"
              title="Permalink to World.clearForces">#</a></h4>
<div class="doc">
<p>Call this after you are done with time steps to clear the forces.
You normally call this after each call to Step, unless you are
performing sub-steps. By default, forces will be automatically cleared,
so you don't need to call this function.</p>
<p>see setAutoClearForces</p>
<pre class="source">
void clearForces() {
 for (Body body = _bodyList; body != null; body = body.next) {
   body._force.setZero();
   body._torque = 0.0;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="createBody">
<button class="show-code">Code</button>
<a href="../box2d/Body.html">Body</a> <strong>createBody</strong>(<a href="../box2d/BodyDef.html">BodyDef</a> def) <a class="anchor-link" href="#createBody"
              title="Permalink to World.createBody">#</a></h4>
<div class="doc">
<p>Create a rigid body given a definition. No reference to the definition
is retained.</p>
<pre class="source">
Body createBody(BodyDef def) {
 assert (locked == false);
 if (locked) {
   return null;
 }
 Body b = new Body(def, this);

 // add to world doubly linked list
 b.prev = null;
 b.next = _bodyList;
 if (_bodyList != null) {
   _bodyList.prev = b;
 }
 _bodyList = b;
 ++_bodyCount;

 return b;
}
</pre>
</div>
</div>
<div class="method"><h4 id="createJoint">
<button class="show-code">Code</button>
<a href="../box2d/Joint.html">Joint</a> <strong>createJoint</strong>(<a href="../box2d/JointDef.html">JointDef</a> def) <a class="anchor-link" href="#createJoint"
              title="Permalink to World.createJoint">#</a></h4>
<div class="doc">
<p>Create a joint to constrain bodies together. No reference to the definition
is retained. This may cause the connected bodies to cease colliding.</p>
<p>Warning: This function is locked during callbacks.</p>
<pre class="source">
Joint createJoint(JointDef def) {
 assert (locked == false);
 if (locked) {
   return null;
 }

 Joint j = new Joint.create(this, def);

 // Connect to the world list.
 j._prev = null;
 j._next = _jointList;
 if (_jointList != null) _jointList._prev = j;
 _jointList = j;
 ++_jointCount;

 // Connect to the bodies' doubly linked lists.
 j.edgeA.joint = j;
 j.edgeA.other = j.bodyB;
 j.edgeA.prev = null;
 j.edgeA.next = j.bodyA.jointList;
 if (j.bodyA.jointList != null) {
   j.bodyA.jointList.prev = j.edgeA;
 }
 j.bodyA.jointList = j.edgeA;

 j.edgeB.joint = j;
 j.edgeB.other = j.bodyA;
 j.edgeB.prev = null;
 j.edgeB.next = j.bodyB.jointList;
 if (j.bodyB.jointList != null) {
   j.bodyB.jointList.prev = j.edgeB;
 }
 j.bodyB.jointList = j.edgeB;

 Body bodyA = def.bodyA;
 Body bodyB = def.bodyB;

 // If the joint prevents collisions, then flag any contacts for filtering.
 if (def.collideConnected == false) {
   ContactEdge edge = bodyB.contactList;
   while (edge != null) {
     if (edge.other == bodyA) {
       // Flag the contact for filtering at the next time step (where either
       // body is awake).
       edge.contact.flagForFiltering();
     }

     edge = edge.next;
   }
 }

 // Note: creating a joint doesn't wake the bodies.

 return j;
}
</pre>
</div>
</div>
<div class="method"><h4 id="destroyBody">
<button class="show-code">Code</button>
void <strong>destroyBody</strong>(<a href="../box2d/Body.html">Body</a> body) <a class="anchor-link" href="#destroyBody"
              title="Permalink to World.destroyBody">#</a></h4>
<div class="doc">
<p>Destroy a rigid body given a definition. No reference to the definition
is retained. This function is locked during callbacks.</p>
<p>warning: This automatically deletes all associated shapes.
warning: This function is locked during callbacks.</p>
<pre class="source">
void destroyBody(Body body) {
 assert (_bodyCount &gt; 0);
 assert (locked == false);
 if (locked) {
   return;
 }

 // Delete the attached joints.
 JointEdge je = body.jointList;
 while (je != null) {
   JointEdge je0 = je;
   je = je.next;
   if (_jointDestructionListener != null) {
     _jointDestructionListener(je0.joint);
   }

   destroyJoint(je0.joint);
 }
 body.jointList = null;

 // Delete the attached contacts.
 ContactEdge ce = body.contactList;
 while (ce != null) {
   ContactEdge ce0 = ce;
   ce = ce.next;
   _contactManager.destroy(ce0.contact);
 }
 body.contactList = null;

 Fixture f = body.fixtureList;
 while (f != null) {
   Fixture f0 = f;
   f = f.next;

   if (_fixtureDestructionListener != null) {
     _fixtureDestructionListener(f0);
   }

   f0.destroyProxy(_contactManager.broadPhase);
   f0.destroy();
   // TODO djm recycle fixtures (here or in that destroy method)
 }
 body.fixtureList = null;
 body.fixtureCount = 0;

 // Remove world body list.
 if (body.prev != null) {
   body.prev.next = body.next;
 }

 if (body.next != null) {
   body.next.prev = body.prev;
 }

 if (body == _bodyList) {
   _bodyList = body.next;
 }

 --_bodyCount;
}
</pre>
</div>
</div>
<div class="method"><h4 id="destroyJoint">
<button class="show-code">Code</button>
void <strong>destroyJoint</strong>(<a href="../box2d/Joint.html">Joint</a> joint) <a class="anchor-link" href="#destroyJoint"
              title="Permalink to World.destroyJoint">#</a></h4>
<div class="doc">
<p>Destroy a joint. This may cause the connected bodies to begin colliding.</p>
<p>Warning: This function is locked during callbacks.</p>
<pre class="source">
void destroyJoint(Joint joint) {
 assert (locked == false);
 if (locked) {
   return;
 }

 bool collideConnected = joint.collideConnected;

 // Remove from the doubly linked list.
 if (joint._prev != null) joint._prev._next = joint._next;

 if (joint._next != null) joint._next._prev = joint._prev;

 if (joint == _jointList) _jointList = joint._next;

 // Disconnect from island graph.
 Body bodyA = joint.bodyA;
 Body bodyB = joint.bodyB;

 // Wake up connected bodies.
 bodyA.awake = true;
 bodyB.awake = true;

 // Remove from body 1.
 if (joint.edgeA.prev != null) {
   joint.edgeA.prev.next = joint.edgeA.next;
 }

 if (joint.edgeA.next != null) {
   joint.edgeA.next.prev = joint.edgeA.prev;
 }

 if (joint.edgeA == bodyA.jointList) {
   bodyA.jointList = joint.edgeA.next;
 }

 joint.edgeA.prev = null;
 joint.edgeA.next = null;

 // Remove from body 2
 if (joint.edgeB.prev != null) {
   joint.edgeB.prev.next = joint.edgeB.next;
 }

 if (joint.edgeB.next != null) {
   joint.edgeB.next.prev = joint.edgeB.prev;
 }

 if (joint.edgeB == bodyB.jointList) {
   bodyB.jointList = joint.edgeB.next;
 }

 joint.edgeB.prev = null;
 joint.edgeB.next = null;

 Joint.destroy(joint);

 assert (_jointCount &gt; 0);
 --_jointCount;

 // If the joint prevents collisions, then flag any contacts for filtering.
 if (collideConnected == false) {
   ContactEdge edge = bodyB.contactList;
   while (edge != null) {
     if (edge.other == bodyA) {
       // Flag the contact for filtering at the next time step (where either
       // body is awake).
       edge.contact.flagForFiltering();
     }

     edge = edge.next;
   }
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="drawDebugData">
<button class="show-code">Code</button>
void <strong>drawDebugData</strong>() <a class="anchor-link" href="#drawDebugData"
              title="Permalink to World.drawDebugData">#</a></h4>
<div class="doc">
<p>Call this to draw shapes and other debug draw data.</p>
<pre class="source">
void drawDebugData() {
 if (_debugDraw == null) {
   return;
 }

 final int drawFlags = _debugDraw.flags;

 if ((drawFlags &amp; DebugDraw.e_shapeBit) == DebugDraw.e_shapeBit) {
   Transform xf = new Transform();
   Color3 color = new Color3();
   for (Body b = _bodyList; b != null; b = b.next) {
     xf.setFrom(b.originTransform);
     for (Fixture f = b.fixtureList; f != null; f = f.next) {
       if (b.active == false) {
         color.setFromRGBF(0.5, 0.5, 0.3);
         drawShape(f, xf, color);
       } else if (b.type == BodyType.STATIC) {
         color.setFromRGBF(0.5, 0.9, 0.3);
         drawShape(f, xf, color);
       } else if (b.type == BodyType.KINEMATIC) {
         color.setFromRGBF(0.5, 0.5, 0.9);
         drawShape(f, xf, color);
       } else if (b.awake == false) {
         color.setFromRGBF(0.9, 0.9, 0.9);
         drawShape(f, xf, color);
       } else {
         color.setFromRGBF(0.9, 0.7, 0.7);
         drawShape(f, xf, color);
       }
     }
   }
 }

 if ((drawFlags &amp; DebugDraw.e_jointBit) == DebugDraw.e_jointBit) {
   for (Joint j = _jointList; j != null; j = j._next)
     drawJoint(j);
 }

 if ((drawFlags &amp; DebugDraw.e_pairBit) == DebugDraw.e_pairBit) {
   Color3 color = new Color3.fromRGBF(0.3, 0.9, 0.9);
   for (Contact c = _contactManager.contactList; c != null; c = c.next) {
     Fixture fixtureA = c.fixtureA;
     Fixture fixtureB = c.fixtureB;

     cA.setFrom(fixtureA.box.center);
     cB.setFrom(fixtureB.box.center);

     _debugDraw.drawSegment(cA, cB, color);
   }
 }

 if ((drawFlags &amp; DebugDraw.e_aabbBit) == DebugDraw.e_aabbBit) {
   Color3 color = new Color3.fromRGBF(0.9, 0.3, 0.9);

   for (Body b = _bodyList; b != null; b = b.next) {
     if (!b.active) {
       continue;
     }

     for (Fixture f = b.fixtureList; f != null; f = f.next) {
       AxisAlignedBox aabb = f.proxy.box;

       List&lt;Vector2&gt; vs = new List&lt;Vector2&gt;(4);
       for (int i = 0; i &lt; vs.length; i++) {
         vs[i] = new Vector2.zero();
       }

       vs[0].setValues(aabb.lowerBound.x, aabb.lowerBound.y);
       vs[1].setValues(aabb.upperBound.x, aabb.lowerBound.y);
       vs[2].setValues(aabb.upperBound.x, aabb.upperBound.y);
       vs[3].setValues(aabb.lowerBound.x, aabb.upperBound.y);

       if (0 != (drawFlags &amp; DebugDraw.e_lineDrawingBit)) {
         _debugDraw.drawPolygon(vs, 4, color);
       } else {
         _debugDraw.drawSolidPolygon(vs, 4, color);
       }
     }
   }
 }

 if ((drawFlags &amp; DebugDraw.e_centerOfMassBit) ==
     DebugDraw.e_centerOfMassBit) {
   Transform xf = new Transform();
   final Color3 color = new Color3.fromRGB(1, 0, 0);
   for (Body b = _bodyList; b != null; b = b.next) {
     xf.setFrom(b.originTransform);
     xf.position.setFrom(b.worldCenter);
     _debugDraw.drawTransform(xf, color);
   }
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="drawJoint">
<button class="show-code">Code</button>
void <strong>drawJoint</strong>(<a href="../box2d/Joint.html">Joint</a> joint) <a class="anchor-link" href="#drawJoint"
              title="Permalink to World.drawJoint">#</a></h4>
<div class="doc">
<p>Draws a joint for debugging purposes. </p>
<pre class="source">
void drawJoint(Joint joint) {
 Body bodyA = joint.bodyA;
 Body bodyB = joint.bodyB;
 Transform xf1 = bodyA.originTransform;
 Transform xf2 = bodyB.originTransform;
 Vector2 x1 = new Vector2.copy(xf1.position);
 Vector2 x2 = new Vector2.copy(xf2.position);
 Vector2 p1 = new Vector2.zero();
 Vector2 p2 = new Vector2.zero();
 joint.getAnchorA(p1);
 joint.getAnchorB(p2);

 // Set the drawing color.
 Color3 color = new Color3.fromRGBF(0.5, 0.3, 0.3);

 switch (joint.type) {
   case JointType.DISTANCE :
     _debugDraw.drawSegment(p1, p2, color);
     break;

   case JointType.PULLEY :
     throw new UnimplementedError();
     //Vector2 s1 = pulley.getGroundAnchorA();
     //Vector2 s2 = pulley.getGroundAnchorB();
     //_debugDraw.drawSegment(s1, p1, color);
     //_debugDraw.drawSegment(s2, p2, color);
     //_debugDraw.drawSegment(s1, s2, color);
     //break;

   case JointType.FRICTION:
     _debugDraw.drawSegment(x1, x2, color);
     break;

   case JointType.CONSTANT_VOLUME :
     // Nothing to see here.
   case JointType.MOUSE :
     // Don't draw anything for mouse. Already have cursor!
     break;
   default :
     Vector2 p1t = new Vector2.copy(p1); // copies since drawSegment modifies
     Vector2 p2t = new Vector2.copy(p2);
     _debugDraw.drawSegment(x1, p1, color);
     _debugDraw.drawSegment(p1t, p2, color);
     _debugDraw.drawSegment(x2, p2t, color);
     break;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="drawShape">
<button class="show-code">Code</button>
void <strong>drawShape</strong>(<a href="../box2d/Fixture.html">Fixture</a> fixture, <a href="../box2d/Transform.html">Transform</a> xf, <a href="../box2d/Color3.html">Color3</a> color) <a class="anchor-link" href="#drawShape"
              title="Permalink to World.drawShape">#</a></h4>
<div class="doc">
<pre class="source">
void drawShape(Fixture fixture, Transform xf, Color3 color) {
 switch (fixture.type) {
   case ShapeType.CIRCLE:
     final CircleShape circle = fixture.shape;

     // Vector2 center = Mul(xf, circle.p);
     Transform.mulToOut(xf, circle.position, center);
     num radius = circle.radius;
     axis.setValues(xf.rotation.entry(0,0), xf.rotation.entry(1,0));

     if (0 != (_debugDraw.flags &amp; DebugDraw.e_lineDrawingBit)) {
       _debugDraw.drawCircle(center, radius, color, axis);
     } else {
       _debugDraw.drawSolidCircle(center, radius, color, axis);
     }
     break;

   case ShapeType.POLYGON:
     final PolygonShape poly = fixture.shape;
     int vertexCount = poly.vertexCount;
     assert (vertexCount &lt;= Settings.MAX_POLYGON_VERTICES);
     List&lt;Vector2&gt; vertices = new List&lt;Vector2&gt;.generate(
         vertexCount, (i) =&gt; new Vector2.zero());

     for (int i = 0; i &lt; vertexCount; ++i) {
       assert(poly.vertices[i] != null);
       assert(vertices[i] != null);
       Transform.mulToOut(xf, poly.vertices[i], vertices[i]);
     }

     if (0 != (_debugDraw.flags &amp; DebugDraw.e_lineDrawingBit)) {
       _debugDraw.drawPolygon(vertices, vertexCount, color);
     } else if (vertexCount &gt; 2) {
       _debugDraw.drawSolidPolygon(vertices, vertexCount, color);
     } else {
       _debugDraw.drawPolygon(vertices, vertexCount, color);
     }
     break;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="popContact">
<button class="show-code">Code</button>
<a href="../box2d/Contact.html">Contact</a> <strong>popContact</strong>(<a href="../box2d/Fixture.html">Fixture</a> fixtureA, <a href="../box2d/Fixture.html">Fixture</a> fixtureB) <a class="anchor-link" href="#popContact"
              title="Permalink to World.popContact">#</a></h4>
<div class="doc">
<pre class="source">
Contact popContact(Fixture fixtureA, Fixture fixtureB) {
 int type1 = fixtureA.type;
 int type2 = fixtureB.type;

 ContactRegister reg = _contactStacks[type1][type2];
 Queue&lt;Contact&gt; creator = reg.creator;
 if (creator != null) {

   // Ensure that the creator isn't depleted of contact stacks.
   if (creator.isEmpty) {
     creator = _getFreshContactStack(type1, type2);
   }

   if (reg.primary) {
     Contact c = creator.removeFirst();
     c.init(fixtureA, fixtureB);
     return c;
   } else {
     Contact c = creator.removeFirst();
     c.init(fixtureB, fixtureA);
     return c;
   }
 } else {
   return null;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="pushContact">
<button class="show-code">Code</button>
void <strong>pushContact</strong>(<a href="../box2d/Contact.html">Contact</a> contact) <a class="anchor-link" href="#pushContact"
              title="Permalink to World.pushContact">#</a></h4>
<div class="doc">
<pre class="source">
void pushContact(Contact contact) {
 if (contact.manifold.pointCount &gt; 0) {
   contact.fixtureA.body.awake = true;
   contact.fixtureB.body.awake = true;
 }

 int type1 = contact.fixtureA.type;
 int type2 = contact.fixtureB.type;

 Queue&lt;Contact&gt; creator = _contactStacks[type1][type2].creator;
 creator.addFirst(contact);
}
</pre>
</div>
</div>
<div class="method"><h4 id="queryAABB">
<button class="show-code">Code</button>
void <strong>queryAABB</strong>(<a href="../box2d/QueryCallback.html">QueryCallback</a> callback, <a href="../box2d/AxisAlignedBox.html">AxisAlignedBox</a> aabb) <a class="anchor-link" href="#queryAABB"
              title="Permalink to World.queryAABB">#</a></h4>
<div class="doc">
<p>Query the world for all fixtures that potentially overlap the
provided AABB.</p>
<p>param callback
  a user implemented callback class.
param aabb
  the query box.</p>
<pre class="source">
void queryAABB(QueryCallback callback, AxisAlignedBox aabb) {
 wqwrapper.broadPhase = _contactManager.broadPhase;
 wqwrapper.callback = callback;
 _contactManager.broadPhase.query(wqwrapper, aabb);
}
</pre>
</div>
</div>
<div class="method"><h4 id="solve">
<button class="show-code">Code</button>
void <strong>solve</strong>(<a href="../box2d/TimeStep.html">TimeStep</a> timeStep) <a class="anchor-link" href="#solve"
              title="Permalink to World.solve">#</a></h4>
<div class="doc">
<pre class="source">
void solve(TimeStep timeStep) {
 // Size the  for the worst case.
 island.init(_bodyCount, _contactManager.contactCount, _jointCount,
     _contactManager.contactListener);

 // Clear all the island flags.
 for (Body b = _bodyList; b != null; b = b.next) {
   b.flags &amp;= ~Body.ISLAND_FLAG;
 }
 for (Contact c = _contactManager.contactList; c != null; c = c.next) {
   c.flags &amp;= ~Contact.ISLAND_FLAG;
 }
 for (Joint j = jointList; j != null; j = j._next) {
   j.islandFlag = false;
 }

 // Build and simulate all awake islands.
 int stackSize = _bodyCount;
 if (stack.length &lt; stackSize) {
   stack = new List&lt;Body&gt;(stackSize);
 }

 for (Body seed = _bodyList; seed != null; seed = seed.next) {
   if ((seed.flags &amp; Body.ISLAND_FLAG) == Body.ISLAND_FLAG) {
     continue;
   }

   if (seed.awake == false || seed.active == false) {
     continue;
   }

   // The seed can be dynamic or kinematic.
   if (seed.type == BodyType.STATIC) {
     continue;
   }

   // Reset island and stack.
   island.clear();
   int stackCount = 0;
   stack[stackCount++] = seed;
   seed.flags |= Body.ISLAND_FLAG;

   // Perform a depth first search (DFS) on the constraint graph.
   while (stackCount &gt; 0) {
     // Grab the next body off the stack and add it to the island.
     Body b = stack[--stackCount];
     assert (b.active);
     island.addBody(b);

     // Make sure the body is awake.
     b.awake = true;

     // To keep islands as small as possible, we don't
     // propagate islands across static bodies.
     if (b.type == BodyType.STATIC) {
       continue;
     }

     // Search all contacts connected to this body.
     for (ContactEdge ce = b.contactList; ce != null; ce = ce.next) {
       Contact contact = ce.contact;

       // Has this contact already been added to an island?
       if ((contact.flags &amp; Contact.ISLAND_FLAG) == Contact.ISLAND_FLAG) {
         continue;
       }

       // Is this contact solid and touching?
       if (contact.enabled == false || contact.touching == false) {
         continue;
       }

       // Skip sensors.
       bool sensorA = contact.fixtureA.isSensor;
       bool sensorB = contact.fixtureB.isSensor;
       if (sensorA || sensorB) {
         continue;
       }

       island.addContact(contact);
       contact.flags |= Contact.ISLAND_FLAG;

       Body other = ce.other;

       // Was the other body already added to this island?
       if ((other.flags &amp; Body.ISLAND_FLAG) == Body.ISLAND_FLAG) {
         continue;
       }

       assert (stackCount &lt; stackSize);
       stack[stackCount++] = other;
       other.flags |= Body.ISLAND_FLAG;
     }

     // Search all joints connect to this body.
     for (JointEdge je = b.jointList; je != null; je = je.next) {
       if (je.joint.islandFlag == true) {
         continue;
       }

       Body other = je.other;

       // Don't simulate joints connected to inactive bodies.
       if (other.active == false) {
         continue;
       }

       island.addJoint(je.joint);
       je.joint.islandFlag = true;

       if (((other.flags &amp; Body.ISLAND_FLAG) == Body.ISLAND_FLAG)) {
         continue;
       }

       assert (stackCount &lt; stackSize);
       stack[stackCount++] = other;
       other.flags |= Body.ISLAND_FLAG;
     }
   }

   island.solve(timeStep, _gravity, _allowSleep);

   // Post solve cleanup.
   for (int i = 0; i &lt; island.bodyCount; ++i) {
     // Allow static bodies to participate in other islands.
     Body b = island.bodies[i];
     if (b.type == BodyType.STATIC) {
       b.flags &amp;= ~Body.ISLAND_FLAG;
     }
   }
 }

 // Synchronize fixtures, check for out of range bodies.
 for (Body b = _bodyList; b != null; b = b.next) {
   // If a body was not in an island then it did not move.
   if ((b.flags &amp; Body.ISLAND_FLAG) == 0) {
     continue;
   }

   if (b.type == BodyType.STATIC) {
     continue;
   }

   // Update fixtures (for broad-phase).
   b.synchronizeFixtures();
 }

 // Look for new contacts.
 _contactManager.findNewContacts();
}
</pre>
</div>
</div>
<div class="method"><h4 id="solveTimeOfImpact">
<button class="show-code">Code</button>
void <strong>solveTimeOfImpact</strong>() <a class="anchor-link" href="#solveTimeOfImpact"
              title="Permalink to World.solveTimeOfImpact">#</a></h4>
<div class="doc">
<pre class="source">
void solveTimeOfImpact() {
 // Prepare all contacts.
 for (Contact c = _contactManager.contactList; c != null; c = c.next) {
   // Enable the contact
   c.flags |= Contact.ENABLED_FLAG;

   // Set the number of TimeOfImpact events for this contact to zero.
   c.toiCount = 0;
 }

 // Initialize the TimeOfImpact flag.
 for (Body body = _bodyList; body != null; body = body.next) {
   // Kinematic, and static bodies will not be affected by the TimeOfImpact
   // event.  If a body was not in an island then it did not move.
   if ((body.flags &amp; Body.ISLAND_FLAG) == 0 ||
       body.type == BodyType.KINEMATIC ||
       body.type == BodyType.STATIC) {
     body.flags |= Body.TO_I_FLAG;
   } else {
     body.flags &amp;= ~Body.TO_I_FLAG;
   }
 }

 // Collide non-bullets.
 for (Body body = _bodyList; body != null; body = body.next) {
   if ((body.flags &amp; Body.TO_I_FLAG) == Body.TO_I_FLAG ||
       body.bullet == true) {
     continue;
   }

   solveTimeOfImpactGivenBody(body);

   body.flags |= Body.TO_I_FLAG;
 }

 // Collide bullets.
 for (Body body = _bodyList; body != null; body = body.next) {
   if ((body.flags &amp; Body.TO_I_FLAG) == Body.TO_I_FLAG ||
       !body.bullet) {
     continue;
   }

   solveTimeOfImpactGivenBody(body);

   body.flags |= Body.TO_I_FLAG;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="solveTimeOfImpactGivenBody">
<button class="show-code">Code</button>
void <strong>solveTimeOfImpactGivenBody</strong>(<a href="../box2d/Body.html">Body</a> body) <a class="anchor-link" href="#solveTimeOfImpactGivenBody"
              title="Permalink to World.solveTimeOfImpactGivenBody">#</a></h4>
<div class="doc">
<pre class="source">
void solveTimeOfImpactGivenBody(Body body) {
 // Find the minimum contact.
 Contact toiContact = null;
 num toi = 1.0;
 Body toiOther = null;
 bool found;
 int count;
 int iter = 0;

 bool bullet = body.bullet;

 // Iterate until all contacts agree on the minimum TimeOfImpact. We have
 // to iterate because the TimeOfImpact algorithm may skip some intermediate
 // collisions when objects rotate through each other.
 do {
   count = 0;
   found = false;
   for (ContactEdge ce = body.contactList; ce != null; ce = ce.next) {
     if (ce.contact == toiContact) {
       continue;
     }

     Body other = ce.other;
     int type = other.type;

     // Only bullets perform TimeOfImpact with dynamic bodies.
     if (bullet) {
       // Bullets only perform TimeOfImpact with bodies that have their
       // TimeOfImpact resolved.
       if ((other.flags &amp; Body.TO_I_FLAG) == 0) {
         continue;
       }

       // No repeated hits on non-static bodies
       if (type != BodyType.STATIC &amp;&amp;
           (ce.contact.flags &amp; Contact.BULLET_HIT_FLAG) != 0) {
         continue;
       }
     } else if (type == BodyType.DYNAMIC) {
       continue;
     }

     // Check for a disabled contact.
     // Prevent infinite looping.
     Contact contact = ce.contact;
     if (!contact.enabled || contact.toiCount &gt; 10) {
       continue;
     }

     Fixture fixtureA = contact.fixtureA;
     Fixture fixtureB = contact.fixtureB;

     // Cull sensors.
     if (fixtureA.isSensor || fixtureB.isSensor) {
       continue;
     }

     Body bodyA = fixtureA.body;
     Body bodyB = fixtureB.body;

     // Compute the time of impact in interval [0, minTimeOfImpact]
     toiInput.proxyA.setFromShape(fixtureA.shape);
     toiInput.proxyB.setFromShape(fixtureB.shape);
     toiInput.sweepA.setFrom(bodyA.sweep);
     toiInput.sweepB.setFrom(bodyB.sweep);
     toiInput.tMax = toi;

     _pool.timeOfImpact.timeOfImpact(toiOutput, toiInput);

     if (toiOutput.state == TimeOfImpactOutputState.TOUCHING &amp;&amp;
         toiOutput.t &lt; toi) {
       toiContact = contact;
       toi = toiOutput.t;
       toiOther = other;
       found = true;
     }

     ++count;
   }

   ++iter;
 } while (found &amp;&amp; count &gt; 1 &amp;&amp; iter &lt; 50);

 if (toiContact == null) {
   body.advance(1.0);
   return;
 }

 backup.setFrom(body.sweep);
 body.advance(toi);
 toiContact.update(_contactManager.contactListener);
 if (toiContact.enabled == false) {
   // Contact disabled. Backup and recurse.
   body.sweep.setFrom(backup);
   solveTimeOfImpactGivenBody(body);
 }

 ++toiContact.toiCount;

 // Update all the valid contacts on this body and build a contact island.
 if (contacts == null ||
     contacts.length &lt; Settings.MAX_TIME_OF_IMPACT_CONTACTS) {
   contacts = new List&lt;Contact&gt;(Settings.MAX_TIME_OF_IMPACT_CONTACTS);
 }

 count = 0;
 for (ContactEdge ce = body.contactList; ce != null &amp;&amp;
      count &lt; Settings.MAX_TIME_OF_IMPACT_CONTACTS;
      ce = ce.next) {
   Body other = ce.other;
   int type = other.type;

   // Only perform correction with static bodies, so the
   // body won't get pushed out of the world.
   if (type == BodyType.DYNAMIC) {
     continue;
   }

   // Check for a disabled contact.
   Contact contact = ce.contact;
   if (!contact.enabled) {
     continue;
   }

   Fixture fixtureA = contact.fixtureA;
   Fixture fixtureB = contact.fixtureB;

   // Cull sensors.
   if (fixtureA.isSensor || fixtureB.isSensor) {
     continue;
   }

   // The contact likely has some new contact points. The listener
   // gives the user a chance to disable the contact.
   if (contact != toiContact) {
     contact.update(_contactManager.contactListener);
   }

   // Did the user disable the contact?
   if (!contact.enabled || !contact.touching) {
     continue;
   }

   contacts[count] = contact;
   ++count;
 }

 // Reduce the TimeOfImpact body's overlap with the contact island.
 toiSolver.initialize(contacts, count, body);

 num k_toiBaumgarte = 0.75;
 // bool solved = false;
 for (int i = 0; i &lt; 20; ++i) {
   if (toiSolver.solve(k_toiBaumgarte)) {
     // solved = true;
     break;
   }
 }

 if (toiOther.type != BodyType.STATIC) {
   toiContact.flags |= Contact.BULLET_HIT_FLAG;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="step">
<button class="show-code">Code</button>
void <strong>step</strong>(<a href="http://api.dartlang.org/dart_core/double.html">double</a> dt, <a href="http://api.dartlang.org/dart_core/int.html">int</a> velocityIterations, <a href="http://api.dartlang.org/dart_core/int.html">int</a> positionIterations) <a class="anchor-link" href="#step"
              title="Permalink to World.step">#</a></h4>
<div class="doc">
<p>Take a time step. This performs collision detection, integration,
and constraint solution.</p>
<p>param timeStep
  the amount of time to simulate, this should not vary.
param velocityIterations
  for the velocity constraint solver.
param positionIterations
  for the position constraint solver.</p>
<pre class="source">
void step(double dt, int velocityIterations, int positionIterations) {

 // If new fixtures were added, we need to find the new contacts.
 if ((_flags &amp; NEW_FIXTURE) == NEW_FIXTURE) {
   _contactManager.findNewContacts();
   _flags &amp;= ~NEW_FIXTURE;
 }

 _flags |= LOCKED;

 timestep.dt = dt;
 timestep.velocityIterations = velocityIterations;
 timestep.positionIterations = positionIterations;
 if (dt &gt; 0.0) {
   timestep.inv_dt = 1.0 / dt;
 } else {
   timestep.inv_dt = 0.0;
 }

 timestep.dtRatio = _inverseTimestep * dt;
 timestep.warmStarting = _warmStarting;

 // Update contacts. This is where some contacts are destroyed.
 _contactManager.collide();

 // Integrate velocities, solve velocity constraints, and integrate
 // positions.
 if (timestep.dt &gt; 0.0) {
   solve(timestep);
   if (_continuousPhysics) {
     solveTimeOfImpact();
   }
   _inverseTimestep = timestep.inv_dt;
 }

 if ((_flags &amp; CLEAR_FORCES) == CLEAR_FORCES) {
   clearForces();
 }

 _flags &amp;= ~LOCKED;
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
