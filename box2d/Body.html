        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Body class / box2d Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="box2d" data-type="Body">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../box2d.html">box2d</a> &rsaquo; <a href="../box2d/Body.html">Body</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Body</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class Body {
 /** Flags for different states the body can take on. */
 static const int ISLAND_FLAG = 0x0001;
 static const int AWAKE_FLAG = 0x0002;
 static const int AUTO_SLEEP_FLAG = 0x0004;
 static const int BULLET_FLAG = 0x0008;
 static const int FIXED_ROTATION_FLAG = 0x0010;
 static const int ACTIVE_FLAG = 0x0020;
 static const int TO_I_FLAG = 0x0040;

 World world;

 int flags = 0;

 ContactEdge contactList = null;

 double sleepTime = 0.0;

 /** User can store what they want in here. */
 Object userData;

 /** The linear velocity of this body. */
 final Vector2 _linearVelocity;

 /** The angular velocity of this body. */
 double _angularVelocity = 0.0;

 /** This body's mass. */
 double mass;

 /** The inverse of the body mass. */
 double invMass;

 /** For mantaining the linked list of bodies. */
 Body next = null;
 Body prev = null;

 Fixture fixtureList = null;
 int fixtureCount = 0;

 JointEdge jointList = null;

 /** Forces applied on the body. */
 final Vector2 _force = new Vector2.zero();

 double _torque = 0.0;

 /** Rotational intertia about the center of mass. */
 double _inertia = 0.0;

 /** The inverse of the intertia about the center of mass. */
 double invInertia = 0.0;

 double linearDamping;

 double angularDamping;

 /** This body's type. See BodyType.dart. */
 int _type;

 int islandIndex;

 /** The body origin transform. */
 final Transform originTransform = new Transform();

 /** The swept motion for CCD. */
 final Sweep sweep = new Sweep();

 /** Private pool of objects for internal use. */
 final FixtureDef _fixDef = new FixtureDef();
 final MassData _pmd = new MassData();
 final Transform _pxf = new Transform();
 final Vector2 oldCenter = new Vector2.zero();
 final Vector2 tempCenter = new Vector2.zero();

 Body(BodyDef bd, this.world) :
   _linearVelocity = new Vector2.copy(bd.linearVelocity),
   linearDamping = bd.linearDamping,
   angularDamping = bd.angularDamping,
   userData = bd.userData,
   _type = bd.type
 {
   if (bd.bullet) {
     flags |= BULLET_FLAG;
   }
   if (bd.fixedRotation) {
     flags |= FIXED_ROTATION_FLAG;
   }
   if (bd.allowSleep) {
     flags |= AUTO_SLEEP_FLAG;
   }
   if (bd.awake) {
     flags |= AWAKE_FLAG;
   }
   if (bd.active) {
     flags |= ACTIVE_FLAG;
   }

   originTransform.position.setFrom(bd.position);
   originTransform.rotation.setRotation(bd.angle);
   sweep.localCenter.setZero();
   Transform.mulToOut(originTransform, sweep.localCenter, sweep.centerZero);
   sweep.center.setFrom(sweep.centerZero);
   sweep.angle = bd.angle;
   sweep.angleZero = bd.angle;

   if (_type == BodyType.DYNAMIC) {
     mass = 1.0;
     invMass = 1.0;
   } else {
     mass = 0.0;
     invMass = 0.0;
   }
 }

 /**
  * Creates a fixture and attach it to this body. Use this function if you need
  * to set some fixture parameters, like friction. Otherwise you can create the
  * fixture directly from a shape.
  * If the density is non-zero, this function automatically updates the mass
  * of the body.
  * Contacts are not created until the next time step.
  */
 Fixture createFixture(FixtureDef def) {
   assert (world.locked == false);

   Fixture fixture = new Fixture();
   fixture.create(this, def);

   if ((flags &amp; ACTIVE_FLAG) == ACTIVE_FLAG) {
     BroadPhase broadPhase = world._contactManager.broadPhase;
     fixture.createProxy(broadPhase, originTransform);
   }

   fixture.next = fixtureList;
   fixtureList = fixture;
   ++fixtureCount;

   fixture.body = this;

   // Adjust mass properties if needed.
   if (fixture.density &gt; 0.0) {
     resetMassData();
   }

   // Let the world know we have a new fixture. This will cause new contacts
   // to be created at the beginning of the next time step.
   world._flags |= World.NEW_FIXTURE;

   return fixture;
 }

 /**
  * Creates a fixture from a shape and attach it to this body.
  * This is a convenience function. Use FixtureDef if you need to set
  * parameters like friction, restitution, user data, or filtering.
  * If the density is non-zero, this function automatically updates the mass
  * of the body.
  */
 Fixture createFixtureFromShape(Shape shape, [double density = 0.0]) {
   _fixDef.shape = shape;
   _fixDef.density = density;

   return createFixture(_fixDef);
 }

 /**
  * Destroy a fixture. This removes the fixture from the broad-phase and
  * destroys all contacts associated with this fixture. This will
  * automatically adjust the mass of the body if the body is dynamic and the
  * fixture has positive density.
  * All fixtures attached to a body are implicitly destroyed when the body is
  * destroyed.
  */
 void destroyFixture(Fixture fixture) {
   assert (world.locked == false);
   if (world.locked == true) {
     return;
   }

   assert (fixture.body == this);

   // Remove the fixture from this body's singly linked list.
   assert (fixtureCount &gt; 0);
   Fixture node = fixtureList;
   Fixture last = null; // java change
   bool found = false;
   while (node != null) {
     if (node == fixture) {
       node = fixture.next;
       found = true;
       break;
     }
     last = node;
     node = node.next;
   }

   // You tried to remove a shape that is not attached to this body.
   assert (found);

   if (last == null) {
     fixtureList = fixture.next;
   } else {
     last.next = fixture.next;
   }

   // Destroy any contacts associated with the fixture.
   ContactEdge edge = contactList;
   while (edge != null) {
     Contact c = edge.contact;
     edge = edge.next;

     Fixture fixtureA = c.fixtureA;
     Fixture fixtureB = c.fixtureB;

     if (fixture == fixtureA || fixture == fixtureB) {
       // This destroys the contact and removes it from
       // this body's contact list.
       world._contactManager.destroy(c);
     }
   }

   if ((flags &amp; ACTIVE_FLAG) == ACTIVE_FLAG) {
     assert (fixture.proxy != null);
     BroadPhase broadPhase = world._contactManager.broadPhase;
     fixture.destroyProxy(broadPhase);
   } else {
     assert (fixture.proxy == null);
   }

   fixture.destroy();
   fixture.body = null;
   fixture.next = null;
   fixture = null;

   --fixtureCount;

   // Reset the mass data.
   resetMassData();
 }

 /**
  * Set the position of the body's origin and rotation.
  * This breaks any contacts and wakes the other bodies.
  * Manipulating a body's transform may cause non-physical behavior.
  */
 void setTransform(Vector2 argPosition, double argAngle) {
   assert (world.locked == false);
   if (world.locked == true) {
     return;
   }

   originTransform.rotation.setRotation(argAngle);
   originTransform.position.setFrom(argPosition);

   Transform.mulToOut(originTransform, sweep.localCenter, sweep.centerZero);
   sweep.center.setFrom(sweep.centerZero);

   sweep.angleZero = argAngle;
   sweep.angle = argAngle;

   BroadPhase broadPhase = world._contactManager.broadPhase;
   for (Fixture f = fixtureList; f != null; f = f.next) {
     f.synchronize(broadPhase, originTransform, originTransform);
   }

   world._contactManager.findNewContacts();
 }

 /**
  * Get the world body origin position. Do not modify.
  */
 Vector2 get position =&gt; originTransform.position;

 /**
  * Get the angle in radians.
  */
 double get angle =&gt; sweep.angle;

 /**
  * Get the world position of the center of mass. Do not modify.
  */
 Vector2 get worldCenter =&gt; sweep.center;

 /**
  * Get the local position of the center of mass. Do not modify.
  */
 Vector2 get localCenter =&gt; sweep.localCenter;

 Vector2 get linearVelocity =&gt; _linearVelocity;

 void set linearVelocity(Vector2 v) {
   if (_type == BodyType.STATIC) {
     return;
   }

   if (v.dot(v) &gt; 0.0) {
     awake = true;
   }

   _linearVelocity.setFrom(v);
 }

 double get angularVelocity =&gt; _angularVelocity;

 void set angularVelocity(double w) {
   if (_type != BodyType.STATIC) {
     // Set awake if want to set velocity to non-zero value.
     if (w * w &gt; 0) {
       awake = true;
     }

     _angularVelocity = w;
   }
 }

 /**
  * Apply a force at a world point. If the force is not
  * applied at the center of mass, it will generate a torque and
  * affect the angular velocity. This wakes up the body.
  *
  * force
  *   the world force vector, usually in Newtons (N).
  * point
  *   the world position of the point of application.
  */
 void applyForce(Vector2 force, Vector2 point) {
   if (_type != BodyType.DYNAMIC) {
     return;
   }

   awake = true;

   _force.x += force.x;
   _force.y += force.y;

   _torque += (point.x - sweep.center.x) * force.y - (point.y - sweep.center.y)
       * force.x;
 }

 /**
  * Apply a torque. This affects the angular velocity
  * without affecting the linear velocity of the center of mass.
  * This wakes up the body.
  *
  * torque
  *   about the z-axis (out of the screen), usually in N-m.
  */
 void applyTorque(double torque) {
   if (_type != BodyType.DYNAMIC) {
     return;
   }

   awake = true;

   _torque += torque;
 }

 /**
  * Apply an impulse at a point. This immediately modifies the velocity.
  * It also modifies the angular velocity if the point of application
  * is not at the center of mass. This wakes up the body.
  *
  * impulse
  *   the world impulse vector, usually in N-seconds or kg-m/s.
  * point
  *   the world position of the point of application.
  */
 void applyLinearImpulse(Vector2 impulse, Vector2 point) {
   if (_type != BodyType.DYNAMIC) {
     return;
   }

   awake = true;

   _linearVelocity.x += impulse.x * invMass;
   _linearVelocity.y += impulse.y * invMass;

   _angularVelocity += invInertia * ((point.x - sweep.center.x) *
       impulse.y - (point.y - sweep.center.y) * impulse.x);
 }

 /**
  * Apply an angular impulse.
  *
  * impulse
  *   the angular impulse in units of kg*m*m/s
  */
 void applyAngularImpulse(double impulse) {
   if (_type != BodyType.DYNAMIC) {
     return;
   }

   awake = true;
   _angularVelocity += invInertia * impulse;
 }

 /**
  * Get the central rotational inertia of the body.
  *
  * returns the rotational inertia, usually in kg-m^2.
  */
 double get inertia {
   return _inertia + mass * (sweep.localCenter.x * sweep.localCenter.x +
       sweep.localCenter.y * sweep.localCenter.y);
 }

 /**
  * Get the mass data of the body. The rotational inertia is relative
  * to the center of mass. Result is returned through the given out parameter
  * data.
  */
 void getMassData(MassData data) {
   data.mass = mass;
   final Vector2 lc = sweep.localCenter;
   data.inertia = _inertia + mass * lc.length2;
   data.center.x = lc.x;
   data.center.y = lc.y;
 }

 /**
  * Set the mass properties to override the mass properties of the fixtures.
  * Note that this changes the center of mass position.
  * Note that creating or destroying fixtures can also alter the mass.
  * This function has no effect if the body isn't dynamic.
  *
  * data
  *   the mass properties.
  */
 void set massData(MassData data) {
   assert(world.locked == false);
   if (world.locked == true) {
     return;
   }

   if (_type != BodyType.DYNAMIC) {
     return;
   }

   invMass = 0.0;
   _inertia = 0.0;
   invInertia = 0.0;

   mass = data.mass;
   if (mass &lt;= 0.0)
     mass = 1.0;

   invMass = 1.0 / mass;

   if (data.inertia &gt; 0.0 &amp;&amp; (flags &amp; FIXED_ROTATION_FLAG) == 0) {
     _inertia = data.inertia - mass * data.center.dot(data.center);
     assert (_inertia &gt; 0.0);
     invInertia = 1.0 / _inertia;
   }

   // Move center of mass.
   oldCenter.setFrom(sweep.center);
   sweep.localCenter.setFrom(data.center);
   Transform.mulToOut(originTransform, sweep.localCenter, sweep.centerZero);
   sweep.center.setFrom(sweep.centerZero);

   // Update center of mass velocity.
   final Vector2 temp = new Vector2.copy(sweep.center);
   temp.sub(oldCenter);
   temp.scaleOrthogonalInto(_angularVelocity, temp);
   _linearVelocity.add(temp);
 }

 /**
  * This resets the mass properties to the sum of the mass properties of the
  * fixtures.
  * This normally does not need to be called unless you called setMassData to
  * override the mass and you later want to reset the mass.
  */
 void resetMassData() {
   // Compute mass data from shapes. Each shape has its own density.
   mass = 0.0;
   invMass = 0.0;
   _inertia = 0.0;
   invInertia = 0.0;
   sweep.localCenter.setZero();

   // Static and kinematic bodies have zero mass.
   if (_type == BodyType.STATIC || _type == BodyType.KINEMATIC) {
     sweep.center.setFrom(originTransform.position);
     sweep.centerZero.setFrom(originTransform.position);
     return;
   }

   assert (_type == BodyType.DYNAMIC);

   // Accumulate mass over all fixtures.
   tempCenter.setZero();
   MassData massData = _pmd;
   for (Fixture f = fixtureList; f != null; f = f.next) {
     if (f.density == 0.0) {
       continue;
     }
     f.getMassData(massData);
     mass += massData.mass;
     final temp = new Vector2.copy(massData.center);
     temp.scale(massData.mass);
     tempCenter.add(temp);
     _inertia += massData.inertia;
   }

   // Compute center of mass.
   if (mass &gt; 0.0) {
     invMass = 1.0 / mass;
     tempCenter.scale(invMass);
   } else {
     // Force all dynamic bodies to have a positive mass.
     mass = 1.0;
     invMass = 1.0;
   }

   if (_inertia &gt; 0.0 &amp;&amp; (flags &amp; FIXED_ROTATION_FLAG) == 0) {
     // Center the inertia about the center of mass.
     _inertia -= mass * tempCenter.dot(tempCenter);
     assert (_inertia &gt; 0.0);
     invInertia = 1.0 / _inertia;
   } else {
     _inertia = 0.0;
     invInertia = 0.0;
   }

   // Move center of mass.
   oldCenter.setFrom(sweep.center);
   sweep.localCenter.setFrom(tempCenter);
   Transform.mulToOut(originTransform, sweep.localCenter, sweep.centerZero);
   sweep.center.setFrom(sweep.centerZero);

   // Update center of mass velocity.
   final Vector2 temp = new Vector2.copy(sweep.center);
   temp.sub(oldCenter);
   temp.scaleOrthogonalInto(_angularVelocity, temp);
   _linearVelocity.add(temp);
 }

 /**
  * Get the world coordinates of a point given the local coordinates.
  *
  * localPoint
  *   a point on the body measured relative the the body's origin.
  * returns the same point expressed in world coordinates.
  */
 Vector2 getWorldPoint(Vector2 localPoint) {
   Vector2 v = new Vector2.zero();
   getWorldPointToOut(localPoint, v);
   return v;
 }

 /**
  * Get the world coordinates of a point given the local coordinates to the
  * given out parameter.
  */
 void getWorldPointToOut(Vector2 localPoint, Vector2 out) {
   Transform.mulToOut(originTransform, localPoint, out);
 }

 /**
  * Get the world coordinates of a vector given the local coordinates.
  *
  * localVector: a vector fixed in the body.
  * return the same vector expressed in world coordinates.
  */
 Vector2 getWorldVector2(Vector2 localVector) {
   Vector2 out = new Vector2.zero();
   getWorldVectorToOut(localVector, out);
   return out;
 }

 /**
  * Get the world coordinates of a vector given the local coordinates to the
  * given out paramater.
  */
 void getWorldVectorToOut(Vector2 localVector, Vector2 out) {
   originTransform.rotation.transformed(localVector,
       out);
 }

 /**
  * Gets a local point relative to the body's origin given a world point.
  * Returns this through the given out parameter.
  */
 void getLocalPointToOut(Vector2 worldPoint, Vector2 out) {
   Transform.mulTransToOut(originTransform, worldPoint, out);
 }

 /**
  * Gets a local point relative to the body's origin given a world point.
  *
  * worldPoint: point in world coordinates.
  * returns the corresponding local point relative to the body's origin.
  */
 Vector2 getLocalPoint(Vector2 worldPoint) {
   Vector2 out = new Vector2.zero();
   getLocalPointToOut(worldPoint, out);
   return out;
 }

 /**
  * Gets a local vector given a world vector.
  *
  * worldVector: vector in world coordinates.
  * returns the corresponding local vector.
  */
 Vector2 getLocalVector2(Vector2 worldVector) {
   Vector2 out = new Vector2.zero();
   getLocalVectorToOut(worldVector, out);
   return out;
 }

 /**
  * Gets a local vector given a world vector and stores the result in the given
  * out parameter.
  */
 void getLocalVectorToOut(Vector2 worldVector, Vector2 out) {
   originTransform.rotation.transposed().transformed(worldVector,
       out);
 }

 /**
  * Get the world linear velocity of a world point attached to this body.
  *
  * worldPoint: point in world coordinates.
  * returns the world velocity of a point.
  */
 Vector2 getLinearVelocityFromWorldPoint(Vector2 worldPoint) {
   Vector2 out = new Vector2.zero();
   getLinearVelocityFromWorldPointToOut(worldPoint, out);
   return out;
 }

 void getLinearVelocityFromWorldPointToOut(Vector2 worldPoint, Vector2 out) {
   out.setFrom(worldPoint).sub(sweep.center);
   out.scaleOrthogonalInto(_angularVelocity, out);
   out.add(_linearVelocity);
 }

 /**
  * Get the world velocity of a local point.
  *
  * localPoint: point in local coordinates.
  * returns the world velocity of a point.
  */
 Vector2 getLinearVelocityFromLocalPoint(Vector2 localPoint) {
   Vector2 out = new Vector2.zero();
   getLinearVelocityFromLocalPointToOut(localPoint, out);
   return out;
 }

 /**
  * Get the world velocity of a local point and store the result in the given
  * out parameter.
  */
 void getLinearVelocityFromLocalPointToOut(Vector2 localPoint, Vector2 out) {
   getWorldPointToOut(localPoint, out);
   getLinearVelocityFromWorldPointToOut(out, out);
 }

 /**
  * The type of this body. Either dynamic, static, or kinematic.
  */
 int get type =&gt; _type;

 /**
  * The type of this body. This may alter the mass and velocity.
  */
 void set type(int otherType) {
   if (_type == otherType) {
     return;
   }

   _type = otherType;

   resetMassData();

   if (_type == BodyType.STATIC) {
     _linearVelocity.setZero();
     _angularVelocity = 0.0;
   }

   awake = true;

   _force.setZero();
   _torque = 0.0;

   // Since the body type changed, we need to flag contacts for filtering.
   for (ContactEdge ce = contactList; ce != null; ce = ce.next) {
     ce.contact.flagForFiltering();
   }
 }

 /** Is this body treated like a bullet for continuous collision detection? */
 bool get bullet =&gt; (flags &amp; BULLET_FLAG) == BULLET_FLAG;

 /**
  * Should this body be treated like a bullet for continuous collision
  * detection?
  */
 void set bullet(bool flag) {
   if (flag)
     flags |= BULLET_FLAG;
   else
     flags &amp;= ~BULLET_FLAG;
 }

 /**
  * You can disable sleeping on this body. If you disable sleeping, the
  * body will be woken.
  */
 void set sleepingAllowed(bool flag) {
   if (flag) {
     flags |= AUTO_SLEEP_FLAG;
   } else {
     flags &amp;= ~AUTO_SLEEP_FLAG;
     awake = true;
   }
 }

 /**
  * Is this body allowed to sleep?
  */
 bool get sleepingAllowed =&gt; (flags &amp; AUTO_SLEEP_FLAG) == AUTO_SLEEP_FLAG;

 /**
  * The sleep state of the body. A sleeping body has very
  * low CPU cost.
  */
 void set awake(bool flag) {
   if (flag) {
     if ((flags &amp; AWAKE_FLAG) == 0) {
       flags |= AWAKE_FLAG;
       sleepTime = 0.0;
     }
   } else {
     flags &amp;= ~AWAKE_FLAG;
     sleepTime = 0.0;
     _linearVelocity.setZero();
     _angularVelocity = 0.0;
     _force.setZero();
     _torque = 0.0;
   }
 }

 bool get awake =&gt; (flags &amp; AWAKE_FLAG) == AWAKE_FLAG;

 /**
  * Set the active state of the body. An inactive body is not
  * simulated and cannot be collided with or woken up.
  * If you pass a flag of true, all fixtures will be added to the
  * broad-phase.
  * If you pass a flag of false, all fixtures will be removed from
  * the broad-phase and all contacts will be destroyed.
  * Fixtures and joints are otherwise unaffected. You may continue
  * to create/destroy fixtures and joints on inactive bodies.
  * Fixtures on an inactive body are implicitly inactive and will
  * not participate in collisions, ray-casts, or queries.
  * Joints connected to an inactive body are implicitly inactive.
  * An inactive body is still owned by a World object and remains
  * in the body list.
  */
 void set active(bool flag) {
   if (flag == active) {
     return;
   }

   if (flag) {
     flags |= ACTIVE_FLAG;

     // Create all proxies.
     BroadPhase broadPhase = world._contactManager.broadPhase;
     for (Fixture f = fixtureList; f != null; f = f.next) {
       f.createProxy(broadPhase, originTransform);
     }

     // Contacts are created the next time step.
   } else {
     flags &amp;= ~ACTIVE_FLAG;

     // Destroy all proxies.
     BroadPhase broadPhase = world._contactManager.broadPhase;
     for (Fixture f = fixtureList; f != null; f = f.next) {
       f.destroyProxy(broadPhase);
     }

     // Destroy the attached contacts.
     ContactEdge ce = contactList;
     while (ce != null) {
       ContactEdge ce0 = ce;
       ce = ce.next;
       world._contactManager.destroy(ce0.contact);
     }
     contactList = null;
   }
 }

 /**
  * Get the active state of the body.
  */
 bool get active =&gt; (flags &amp; ACTIVE_FLAG) == ACTIVE_FLAG;

 /**
  * Set this body to have fixed rotation. This causes the mass
  * to be reset.
  */
 void set fixedRotation(bool flag) {
   if (flag)
     flags |= FIXED_ROTATION_FLAG;
   else
     flags &amp;= ~FIXED_ROTATION_FLAG;

   resetMassData();
 }

 /**
  * Does this body have fixed rotation?
  */
 bool get fixedRotation {
   return (flags &amp; FIXED_ROTATION_FLAG) == FIXED_ROTATION_FLAG;
 }

 void synchronizeFixtures() {
   final Transform xf1 = _pxf;
   xf1.rotation.setRotation(sweep.angleZero);
   xf1.rotation.transformed(sweep.localCenter,
       xf1.position);
   xf1.position.scale(-1.0);
   xf1.position.add(sweep.centerZero);

   BroadPhase broadPhase = world._contactManager.broadPhase;
   for (Fixture f = fixtureList; f != null; f = f.next)
     f.synchronize(broadPhase, xf1, originTransform);
 }

 void synchronizeTransform() {
   final double c = Math.cos(sweep.angle);
   final double s = Math.sin(sweep.angle);
   final Transform t = originTransform;
   final Matrix2 r = t.rotation;
   final Vector2 p = t.position;

   r.setValues(c,s,-s,c);

   p.x = (r.entry(0,0) * sweep.localCenter.x + r.entry(0,1) * sweep.localCenter.y) * -1 +
       sweep.center.x;
   p.y = (r.entry(1,0) * sweep.localCenter.x + r.entry(1,1) * sweep.localCenter.y) * -1 +
       sweep.center.y;
 }

 /**
  * This is used to prevent connected bodies from colliding.
  * It may lie, depending on the collideConnected flag.
  */
 bool shouldCollide(Body other) {
   // At least one body should be dynamic.
   return !(_type != BodyType.DYNAMIC &amp;&amp; other._type != BodyType.DYNAMIC);
 }

 void advance(num t) {
   sweep.advance(t);
   sweep.center.setFrom(sweep.centerZero);
   sweep.angle = sweep.angleZero;
   synchronizeTransform();
 }
}
</pre>
</div>
<div>
<h3>Static Properties</h3>
<div class="field"><h4 id="ACTIVE_FLAG">
<button class="show-code">Code</button>
const <a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a>         <strong>ACTIVE_FLAG</strong> <a class="anchor-link"
            href="#ACTIVE_FLAG"
            title="Permalink to Body.ACTIVE_FLAG">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static const int ACTIVE_FLAG = 0x0020
</pre>
</div>
</div>
<div class="field"><h4 id="AUTO_SLEEP_FLAG">
<button class="show-code">Code</button>
const <a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a>         <strong>AUTO_SLEEP_FLAG</strong> <a class="anchor-link"
            href="#AUTO_SLEEP_FLAG"
            title="Permalink to Body.AUTO_SLEEP_FLAG">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static const int AUTO_SLEEP_FLAG = 0x0004
</pre>
</div>
</div>
<div class="field"><h4 id="AWAKE_FLAG">
<button class="show-code">Code</button>
const <a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a>         <strong>AWAKE_FLAG</strong> <a class="anchor-link"
            href="#AWAKE_FLAG"
            title="Permalink to Body.AWAKE_FLAG">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static const int AWAKE_FLAG = 0x0002
</pre>
</div>
</div>
<div class="field"><h4 id="BULLET_FLAG">
<button class="show-code">Code</button>
const <a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a>         <strong>BULLET_FLAG</strong> <a class="anchor-link"
            href="#BULLET_FLAG"
            title="Permalink to Body.BULLET_FLAG">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static const int BULLET_FLAG = 0x0008
</pre>
</div>
</div>
<div class="field"><h4 id="FIXED_ROTATION_FLAG">
<button class="show-code">Code</button>
const <a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a>         <strong>FIXED_ROTATION_FLAG</strong> <a class="anchor-link"
            href="#FIXED_ROTATION_FLAG"
            title="Permalink to Body.FIXED_ROTATION_FLAG">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static const int FIXED_ROTATION_FLAG = 0x0010
</pre>
</div>
</div>
<div class="field"><h4 id="ISLAND_FLAG">
<button class="show-code">Code</button>
const <a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a>         <strong>ISLAND_FLAG</strong> <a class="anchor-link"
            href="#ISLAND_FLAG"
            title="Permalink to Body.ISLAND_FLAG">#</a>
        </h4>
        <div class="doc">
<p>Flags for different states the body can take on. </p>
<pre class="source">
static const int ISLAND_FLAG = 0x0001
</pre>
</div>
</div>
<div class="field"><h4 id="TO_I_FLAG">
<button class="show-code">Code</button>
const <a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a>         <strong>TO_I_FLAG</strong> <a class="anchor-link"
            href="#TO_I_FLAG"
            title="Permalink to Body.TO_I_FLAG">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static const int TO_I_FLAG = 0x0040
</pre>
</div>
</div>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>Body</strong>(<a href="../box2d/BodyDef.html">BodyDef</a> bd, <a href="../box2d/World.html">World</a> world) <a class="anchor-link" href="#"
              title="Permalink to Body.Body">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Creates a new <a class="crossref" href="http://api.dartlang.org/dart_core/Object.html">Object</a> instance.</p>
<p><a class="crossref" href="http://api.dartlang.org/dart_core/Object.html">Object</a> instances have no meaningful state, and are only useful
through their identity. An <a class="crossref" href="http://api.dartlang.org/dart_core/Object.html">Object</a> instance is equal to itself
only.</p>
<div class="docs-inherited-from">docs inherited from <a href="http://api.dartlang.org/dart_core/Object.html" ref="external">Object</a> </div></div>
<pre class="source">
Body(BodyDef bd, this.world) :
 _linearVelocity = new Vector2.copy(bd.linearVelocity),
 linearDamping = bd.linearDamping,
 angularDamping = bd.angularDamping,
 userData = bd.userData,
 _type = bd.type
{
 if (bd.bullet) {
   flags |= BULLET_FLAG;
 }
 if (bd.fixedRotation) {
   flags |= FIXED_ROTATION_FLAG;
 }
 if (bd.allowSleep) {
   flags |= AUTO_SLEEP_FLAG;
 }
 if (bd.awake) {
   flags |= AWAKE_FLAG;
 }
 if (bd.active) {
   flags |= ACTIVE_FLAG;
 }

 originTransform.position.setFrom(bd.position);
 originTransform.rotation.setRotation(bd.angle);
 sweep.localCenter.setZero();
 Transform.mulToOut(originTransform, sweep.localCenter, sweep.centerZero);
 sweep.center.setFrom(sweep.centerZero);
 sweep.angle = bd.angle;
 sweep.angleZero = bd.angle;

 if (_type == BodyType.DYNAMIC) {
   mass = 1.0;
   invMass = 1.0;
 } else {
   mass = 0.0;
   invMass = 0.0;
 }
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="method"><h4 id="active">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>get active</strong> <a class="anchor-link" href="#active"
              title="Permalink to Body.get active">#</a></h4>
<div class="doc">
<p>Get the active state of the body.</p>
<pre class="source">
bool get active =&gt; (flags &amp; ACTIVE_FLAG) == ACTIVE_FLAG;
</pre>
</div>
</div>
<div class="method"><h4 id="active=">
<button class="show-code">Code</button>
void <strong>set active</strong>(<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> flag) <a class="anchor-link" href="#active="
              title="Permalink to Body.set active">#</a></h4>
<div class="doc">
<p>Set the active state of the body. An inactive body is not
simulated and cannot be collided with or woken up.
If you pass a flag of true, all fixtures will be added to the
broad-phase.
If you pass a flag of false, all fixtures will be removed from
the broad-phase and all contacts will be destroyed.
Fixtures and joints are otherwise unaffected. You may continue
to create/destroy fixtures and joints on inactive bodies.
Fixtures on an inactive body are implicitly inactive and will
not participate in collisions, ray-casts, or queries.
Joints connected to an inactive body are implicitly inactive.
An inactive body is still owned by a World object and remains
in the body list.</p>
<pre class="source">
void set active(bool flag) {
 if (flag == active) {
   return;
 }

 if (flag) {
   flags |= ACTIVE_FLAG;

   // Create all proxies.
   BroadPhase broadPhase = world._contactManager.broadPhase;
   for (Fixture f = fixtureList; f != null; f = f.next) {
     f.createProxy(broadPhase, originTransform);
   }

   // Contacts are created the next time step.
 } else {
   flags &amp;= ~ACTIVE_FLAG;

   // Destroy all proxies.
   BroadPhase broadPhase = world._contactManager.broadPhase;
   for (Fixture f = fixtureList; f != null; f = f.next) {
     f.destroyProxy(broadPhase);
   }

   // Destroy the attached contacts.
   ContactEdge ce = contactList;
   while (ce != null) {
     ContactEdge ce0 = ce;
     ce = ce.next;
     world._contactManager.destroy(ce0.contact);
   }
   contactList = null;
 }
}
</pre>
</div>
</div>
<div class="field"><h4 id="angle">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/double.html" ref="external">double</a>         <strong>angle</strong> <a class="anchor-link"
            href="#angle"
            title="Permalink to Body.angle">#</a>
        </h4>
        <div class="doc">
<p>Get the angle in radians.</p>
<pre class="source">
double get angle =&gt; sweep.angle;
</pre>
</div>
</div>
<div class="field"><h4 id="angularDamping">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/double.html" ref="external">double</a>         <strong>angularDamping</strong> <a class="anchor-link"
            href="#angularDamping"
            title="Permalink to Body.angularDamping">#</a>
        </h4>
        <div class="doc">
<pre class="source">
double angularDamping
</pre>
</div>
</div>
<div class="field"><h4 id="angularVelocity">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/double.html" ref="external">double</a>         <strong>angularVelocity</strong> <a class="anchor-link"
            href="#angularVelocity"
            title="Permalink to Body.angularVelocity">#</a>
        </h4>
        <div class="doc">
<pre class="source">
double get angularVelocity =&gt; _angularVelocity;
</pre>
<pre class="source">
void set angularVelocity(double w) {
 if (_type != BodyType.STATIC) {
   // Set awake if want to set velocity to non-zero value.
   if (w * w &gt; 0) {
     awake = true;
   }

   _angularVelocity = w;
 }
}
</pre>
</div>
</div>
<div class="field"><h4 id="awake">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a>         <strong>awake</strong> <a class="anchor-link"
            href="#awake"
            title="Permalink to Body.awake">#</a>
        </h4>
        <div class="doc">
<p>The sleep state of the body. A sleeping body has very
low CPU cost.</p>
<pre class="source">
bool get awake =&gt; (flags &amp; AWAKE_FLAG) == AWAKE_FLAG;
</pre>
<pre class="source">
void set awake(bool flag) {
 if (flag) {
   if ((flags &amp; AWAKE_FLAG) == 0) {
     flags |= AWAKE_FLAG;
     sleepTime = 0.0;
   }
 } else {
   flags &amp;= ~AWAKE_FLAG;
   sleepTime = 0.0;
   _linearVelocity.setZero();
   _angularVelocity = 0.0;
   _force.setZero();
   _torque = 0.0;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="bullet">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>get bullet</strong> <a class="anchor-link" href="#bullet"
              title="Permalink to Body.get bullet">#</a></h4>
<div class="doc">
<p>Is this body treated like a bullet for continuous collision detection? </p>
<pre class="source">
bool get bullet =&gt; (flags &amp; BULLET_FLAG) == BULLET_FLAG;
</pre>
</div>
</div>
<div class="method"><h4 id="bullet=">
<button class="show-code">Code</button>
void <strong>set bullet</strong>(<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> flag) <a class="anchor-link" href="#bullet="
              title="Permalink to Body.set bullet">#</a></h4>
<div class="doc">
<p>Should this body be treated like a bullet for continuous collision
detection?</p>
<pre class="source">
void set bullet(bool flag) {
 if (flag)
   flags |= BULLET_FLAG;
 else
   flags &amp;= ~BULLET_FLAG;
}
</pre>
</div>
</div>
<div class="field"><h4 id="contactList">
<button class="show-code">Code</button>
<a href="../box2d/ContactEdge.html">ContactEdge</a>         <strong>contactList</strong> <a class="anchor-link"
            href="#contactList"
            title="Permalink to Body.contactList">#</a>
        </h4>
        <div class="doc">
<pre class="source">
ContactEdge contactList = null
</pre>
</div>
</div>
<div class="method"><h4 id="fixedRotation">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>get fixedRotation</strong> <a class="anchor-link" href="#fixedRotation"
              title="Permalink to Body.get fixedRotation">#</a></h4>
<div class="doc">
<p>Does this body have fixed rotation?</p>
<pre class="source">
bool get fixedRotation {
 return (flags &amp; FIXED_ROTATION_FLAG) == FIXED_ROTATION_FLAG;
}
</pre>
</div>
</div>
<div class="method"><h4 id="fixedRotation=">
<button class="show-code">Code</button>
void <strong>set fixedRotation</strong>(<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> flag) <a class="anchor-link" href="#fixedRotation="
              title="Permalink to Body.set fixedRotation">#</a></h4>
<div class="doc">
<p>Set this body to have fixed rotation. This causes the mass
to be reset.</p>
<pre class="source">
void set fixedRotation(bool flag) {
 if (flag)
   flags |= FIXED_ROTATION_FLAG;
 else
   flags &amp;= ~FIXED_ROTATION_FLAG;

 resetMassData();
}
</pre>
</div>
</div>
<div class="field"><h4 id="fixtureCount">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a>         <strong>fixtureCount</strong> <a class="anchor-link"
            href="#fixtureCount"
            title="Permalink to Body.fixtureCount">#</a>
        </h4>
        <div class="doc">
<pre class="source">
int fixtureCount = 0
</pre>
</div>
</div>
<div class="field"><h4 id="fixtureList">
<button class="show-code">Code</button>
<a href="../box2d/Fixture.html">Fixture</a>         <strong>fixtureList</strong> <a class="anchor-link"
            href="#fixtureList"
            title="Permalink to Body.fixtureList">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Fixture fixtureList = null
</pre>
</div>
</div>
<div class="field"><h4 id="flags">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a>         <strong>flags</strong> <a class="anchor-link"
            href="#flags"
            title="Permalink to Body.flags">#</a>
        </h4>
        <div class="doc">
<pre class="source">
int flags = 0
</pre>
</div>
</div>
<div class="field"><h4 id="inertia">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/double.html" ref="external">double</a>         <strong>inertia</strong> <a class="anchor-link"
            href="#inertia"
            title="Permalink to Body.inertia">#</a>
        </h4>
        <div class="doc">
<p>Get the central rotational inertia of the body.</p>
<p>returns the rotational inertia, usually in kg-m^2.</p>
<pre class="source">
double get inertia {
 return _inertia + mass * (sweep.localCenter.x * sweep.localCenter.x +
     sweep.localCenter.y * sweep.localCenter.y);
}
</pre>
</div>
</div>
<div class="field"><h4 id="invInertia">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/double.html" ref="external">double</a>         <strong>invInertia</strong> <a class="anchor-link"
            href="#invInertia"
            title="Permalink to Body.invInertia">#</a>
        </h4>
        <div class="doc">
<p>The inverse of the intertia about the center of mass. </p>
<pre class="source">
double invInertia = 0.0
</pre>
</div>
</div>
<div class="field"><h4 id="invMass">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/double.html" ref="external">double</a>         <strong>invMass</strong> <a class="anchor-link"
            href="#invMass"
            title="Permalink to Body.invMass">#</a>
        </h4>
        <div class="doc">
<p>The inverse of the body mass. </p>
<pre class="source">
double invMass
</pre>
</div>
</div>
<div class="field"><h4 id="islandIndex">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a>         <strong>islandIndex</strong> <a class="anchor-link"
            href="#islandIndex"
            title="Permalink to Body.islandIndex">#</a>
        </h4>
        <div class="doc">
<pre class="source">
int islandIndex
</pre>
</div>
</div>
<div class="field"><h4 id="jointList">
<button class="show-code">Code</button>
<a href="../box2d/JointEdge.html">JointEdge</a>         <strong>jointList</strong> <a class="anchor-link"
            href="#jointList"
            title="Permalink to Body.jointList">#</a>
        </h4>
        <div class="doc">
<pre class="source">
JointEdge jointList = null
</pre>
</div>
</div>
<div class="field"><h4 id="linearDamping">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/double.html" ref="external">double</a>         <strong>linearDamping</strong> <a class="anchor-link"
            href="#linearDamping"
            title="Permalink to Body.linearDamping">#</a>
        </h4>
        <div class="doc">
<pre class="source">
double linearDamping
</pre>
</div>
</div>
<div class="field"><h4 id="linearVelocity">
<button class="show-code">Code</button>
<a href="../vector_math_64/Vector2.html">Vector2</a>         <strong>linearVelocity</strong> <a class="anchor-link"
            href="#linearVelocity"
            title="Permalink to Body.linearVelocity">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Vector2 get linearVelocity =&gt; _linearVelocity;
</pre>
<pre class="source">
void set linearVelocity(Vector2 v) {
 if (_type == BodyType.STATIC) {
   return;
 }

 if (v.dot(v) &gt; 0.0) {
   awake = true;
 }

 _linearVelocity.setFrom(v);
}
</pre>
</div>
</div>
<div class="field"><h4 id="localCenter">
<button class="show-code">Code</button>
final <a href="../vector_math_64/Vector2.html">Vector2</a>         <strong>localCenter</strong> <a class="anchor-link"
            href="#localCenter"
            title="Permalink to Body.localCenter">#</a>
        </h4>
        <div class="doc">
<p>Get the local position of the center of mass. Do not modify.</p>
<pre class="source">
Vector2 get localCenter =&gt; sweep.localCenter;
</pre>
</div>
</div>
<div class="field"><h4 id="mass">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/double.html" ref="external">double</a>         <strong>mass</strong> <a class="anchor-link"
            href="#mass"
            title="Permalink to Body.mass">#</a>
        </h4>
        <div class="doc">
<p>This body's mass. </p>
<pre class="source">
double mass
</pre>
</div>
</div>
<div class="method"><h4 id="massData=">
<button class="show-code">Code</button>
void <strong>set massData</strong>(<a href="../box2d/MassData.html">MassData</a> data) <a class="anchor-link" href="#massData="
              title="Permalink to Body.set massData">#</a></h4>
<div class="doc">
<p>Set the mass properties to override the mass properties of the fixtures.
Note that this changes the center of mass position.
Note that creating or destroying fixtures can also alter the mass.
This function has no effect if the body isn't dynamic.</p>
<p>data
  the mass properties.</p>
<pre class="source">
void set massData(MassData data) {
 assert(world.locked == false);
 if (world.locked == true) {
   return;
 }

 if (_type != BodyType.DYNAMIC) {
   return;
 }

 invMass = 0.0;
 _inertia = 0.0;
 invInertia = 0.0;

 mass = data.mass;
 if (mass &lt;= 0.0)
   mass = 1.0;

 invMass = 1.0 / mass;

 if (data.inertia &gt; 0.0 &amp;&amp; (flags &amp; FIXED_ROTATION_FLAG) == 0) {
   _inertia = data.inertia - mass * data.center.dot(data.center);
   assert (_inertia &gt; 0.0);
   invInertia = 1.0 / _inertia;
 }

 // Move center of mass.
 oldCenter.setFrom(sweep.center);
 sweep.localCenter.setFrom(data.center);
 Transform.mulToOut(originTransform, sweep.localCenter, sweep.centerZero);
 sweep.center.setFrom(sweep.centerZero);

 // Update center of mass velocity.
 final Vector2 temp = new Vector2.copy(sweep.center);
 temp.sub(oldCenter);
 temp.scaleOrthogonalInto(_angularVelocity, temp);
 _linearVelocity.add(temp);
}
</pre>
</div>
</div>
<div class="field"><h4 id="next">
<button class="show-code">Code</button>
<a href="../box2d/Body.html">Body</a>         <strong>next</strong> <a class="anchor-link"
            href="#next"
            title="Permalink to Body.next">#</a>
        </h4>
        <div class="doc">
<p>For mantaining the linked list of bodies. </p>
<pre class="source">
Body next = null
</pre>
</div>
</div>
<div class="field"><h4 id="oldCenter">
<button class="show-code">Code</button>
final <a href="../vector_math_64/Vector2.html">Vector2</a>         <strong>oldCenter</strong> <a class="anchor-link"
            href="#oldCenter"
            title="Permalink to Body.oldCenter">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final Vector2 oldCenter = new Vector2.zero()
</pre>
</div>
</div>
<div class="field"><h4 id="originTransform">
<button class="show-code">Code</button>
final <a href="../box2d/Transform.html">Transform</a>         <strong>originTransform</strong> <a class="anchor-link"
            href="#originTransform"
            title="Permalink to Body.originTransform">#</a>
        </h4>
        <div class="doc">
<p>The body origin transform. </p>
<pre class="source">
final Transform originTransform = new Transform()
</pre>
</div>
</div>
<div class="field"><h4 id="position">
<button class="show-code">Code</button>
final <a href="../vector_math_64/Vector2.html">Vector2</a>         <strong>position</strong> <a class="anchor-link"
            href="#position"
            title="Permalink to Body.position">#</a>
        </h4>
        <div class="doc">
<p>Get the world body origin position. Do not modify.</p>
<pre class="source">
Vector2 get position =&gt; originTransform.position;
</pre>
</div>
</div>
<div class="field"><h4 id="prev">
<button class="show-code">Code</button>
<a href="../box2d/Body.html">Body</a>         <strong>prev</strong> <a class="anchor-link"
            href="#prev"
            title="Permalink to Body.prev">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Body prev = null
</pre>
</div>
</div>
<div class="method"><h4 id="sleepingAllowed">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>get sleepingAllowed</strong> <a class="anchor-link" href="#sleepingAllowed"
              title="Permalink to Body.get sleepingAllowed">#</a></h4>
<div class="doc">
<p>Is this body allowed to sleep?</p>
<pre class="source">
bool get sleepingAllowed =&gt; (flags &amp; AUTO_SLEEP_FLAG) == AUTO_SLEEP_FLAG;
</pre>
</div>
</div>
<div class="method"><h4 id="sleepingAllowed=">
<button class="show-code">Code</button>
void <strong>set sleepingAllowed</strong>(<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> flag) <a class="anchor-link" href="#sleepingAllowed="
              title="Permalink to Body.set sleepingAllowed">#</a></h4>
<div class="doc">
<p>You can disable sleeping on this body. If you disable sleeping, the
body will be woken.</p>
<pre class="source">
void set sleepingAllowed(bool flag) {
 if (flag) {
   flags |= AUTO_SLEEP_FLAG;
 } else {
   flags &amp;= ~AUTO_SLEEP_FLAG;
   awake = true;
 }
}
</pre>
</div>
</div>
<div class="field"><h4 id="sleepTime">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/double.html" ref="external">double</a>         <strong>sleepTime</strong> <a class="anchor-link"
            href="#sleepTime"
            title="Permalink to Body.sleepTime">#</a>
        </h4>
        <div class="doc">
<pre class="source">
double sleepTime = 0.0
</pre>
</div>
</div>
<div class="field"><h4 id="sweep">
<button class="show-code">Code</button>
final <a href="../box2d/Sweep.html">Sweep</a>         <strong>sweep</strong> <a class="anchor-link"
            href="#sweep"
            title="Permalink to Body.sweep">#</a>
        </h4>
        <div class="doc">
<p>The swept motion for CCD. </p>
<pre class="source">
final Sweep sweep = new Sweep()
</pre>
</div>
</div>
<div class="field"><h4 id="tempCenter">
<button class="show-code">Code</button>
final <a href="../vector_math_64/Vector2.html">Vector2</a>         <strong>tempCenter</strong> <a class="anchor-link"
            href="#tempCenter"
            title="Permalink to Body.tempCenter">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final Vector2 tempCenter = new Vector2.zero()
</pre>
</div>
</div>
<div class="method"><h4 id="type">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a> <strong>get type</strong> <a class="anchor-link" href="#type"
              title="Permalink to Body.get type">#</a></h4>
<div class="doc">
<p>The type of this body. Either dynamic, static, or kinematic.</p>
<pre class="source">
int get type =&gt; _type;
</pre>
</div>
</div>
<div class="method"><h4 id="type=">
<button class="show-code">Code</button>
void <strong>set type</strong>(<a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a> otherType) <a class="anchor-link" href="#type="
              title="Permalink to Body.set type">#</a></h4>
<div class="doc">
<p>The type of this body. This may alter the mass and velocity.</p>
<pre class="source">
void set type(int otherType) {
 if (_type == otherType) {
   return;
 }

 _type = otherType;

 resetMassData();

 if (_type == BodyType.STATIC) {
   _linearVelocity.setZero();
   _angularVelocity = 0.0;
 }

 awake = true;

 _force.setZero();
 _torque = 0.0;

 // Since the body type changed, we need to flag contacts for filtering.
 for (ContactEdge ce = contactList; ce != null; ce = ce.next) {
   ce.contact.flagForFiltering();
 }
}
</pre>
</div>
</div>
<div class="field"><h4 id="userData">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/Object.html" ref="external">Object</a>         <strong>userData</strong> <a class="anchor-link"
            href="#userData"
            title="Permalink to Body.userData">#</a>
        </h4>
        <div class="doc">
<p>User can store what they want in here. </p>
<pre class="source">
Object userData
</pre>
</div>
</div>
<div class="field"><h4 id="world">
<button class="show-code">Code</button>
<a href="../box2d/World.html">World</a>         <strong>world</strong> <a class="anchor-link"
            href="#world"
            title="Permalink to Body.world">#</a>
        </h4>
        <div class="doc">
<pre class="source">
World world
</pre>
</div>
</div>
<div class="field"><h4 id="worldCenter">
<button class="show-code">Code</button>
final <a href="../vector_math_64/Vector2.html">Vector2</a>         <strong>worldCenter</strong> <a class="anchor-link"
            href="#worldCenter"
            title="Permalink to Body.worldCenter">#</a>
        </h4>
        <div class="doc">
<p>Get the world position of the center of mass. Do not modify.</p>
<pre class="source">
Vector2 get worldCenter =&gt; sweep.center;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="advance">
<button class="show-code">Code</button>
void <strong>advance</strong>(<a href="http://api.dartlang.org/dart_core/num.html" ref="external">num</a> t) <a class="anchor-link" href="#advance"
              title="Permalink to Body.advance">#</a></h4>
<div class="doc">
<pre class="source">
void advance(num t) {
 sweep.advance(t);
 sweep.center.setFrom(sweep.centerZero);
 sweep.angle = sweep.angleZero;
 synchronizeTransform();
}
</pre>
</div>
</div>
<div class="method"><h4 id="applyAngularImpulse">
<button class="show-code">Code</button>
void <strong>applyAngularImpulse</strong>(<a href="http://api.dartlang.org/dart_core/double.html" ref="external">double</a> impulse) <a class="anchor-link" href="#applyAngularImpulse"
              title="Permalink to Body.applyAngularImpulse">#</a></h4>
<div class="doc">
<p>Apply an angular impulse.</p>
<p>impulse
  the angular impulse in units of kg<em>m</em>m/s</p>
<pre class="source">
void applyAngularImpulse(double impulse) {
 if (_type != BodyType.DYNAMIC) {
   return;
 }

 awake = true;
 _angularVelocity += invInertia * impulse;
}
</pre>
</div>
</div>
<div class="method"><h4 id="applyForce">
<button class="show-code">Code</button>
void <strong>applyForce</strong>(<a href="../vector_math_64/Vector2.html">Vector2</a> force, <a href="../vector_math_64/Vector2.html">Vector2</a> point) <a class="anchor-link" href="#applyForce"
              title="Permalink to Body.applyForce">#</a></h4>
<div class="doc">
<p>Apply a force at a world point. If the force is not
applied at the center of mass, it will generate a torque and
affect the angular velocity. This wakes up the body.</p>
<p>force
  the world force vector, usually in Newtons (N).
point
  the world position of the point of application.</p>
<pre class="source">
void applyForce(Vector2 force, Vector2 point) {
 if (_type != BodyType.DYNAMIC) {
   return;
 }

 awake = true;

 _force.x += force.x;
 _force.y += force.y;

 _torque += (point.x - sweep.center.x) * force.y - (point.y - sweep.center.y)
     * force.x;
}
</pre>
</div>
</div>
<div class="method"><h4 id="applyLinearImpulse">
<button class="show-code">Code</button>
void <strong>applyLinearImpulse</strong>(<a href="../vector_math_64/Vector2.html">Vector2</a> impulse, <a href="../vector_math_64/Vector2.html">Vector2</a> point) <a class="anchor-link" href="#applyLinearImpulse"
              title="Permalink to Body.applyLinearImpulse">#</a></h4>
<div class="doc">
<p>Apply an impulse at a point. This immediately modifies the velocity.
It also modifies the angular velocity if the point of application
is not at the center of mass. This wakes up the body.</p>
<p>impulse
  the world impulse vector, usually in N-seconds or kg-m/s.
point
  the world position of the point of application.</p>
<pre class="source">
void applyLinearImpulse(Vector2 impulse, Vector2 point) {
 if (_type != BodyType.DYNAMIC) {
   return;
 }

 awake = true;

 _linearVelocity.x += impulse.x * invMass;
 _linearVelocity.y += impulse.y * invMass;

 _angularVelocity += invInertia * ((point.x - sweep.center.x) *
     impulse.y - (point.y - sweep.center.y) * impulse.x);
}
</pre>
</div>
</div>
<div class="method"><h4 id="applyTorque">
<button class="show-code">Code</button>
void <strong>applyTorque</strong>(<a href="http://api.dartlang.org/dart_core/double.html" ref="external">double</a> torque) <a class="anchor-link" href="#applyTorque"
              title="Permalink to Body.applyTorque">#</a></h4>
<div class="doc">
<p>Apply a torque. This affects the angular velocity
without affecting the linear velocity of the center of mass.
This wakes up the body.</p>
<p>torque
  about the z-axis (out of the screen), usually in N-m.</p>
<pre class="source">
void applyTorque(double torque) {
 if (_type != BodyType.DYNAMIC) {
   return;
 }

 awake = true;

 _torque += torque;
}
</pre>
</div>
</div>
<div class="method"><h4 id="createFixture">
<button class="show-code">Code</button>
<a href="../box2d/Fixture.html">Fixture</a> <strong>createFixture</strong>(<a href="../box2d/FixtureDef.html">FixtureDef</a> def) <a class="anchor-link" href="#createFixture"
              title="Permalink to Body.createFixture">#</a></h4>
<div class="doc">
<p>Creates a fixture and attach it to this body. Use this function if you need
to set some fixture parameters, like friction. Otherwise you can create the
fixture directly from a shape.
If the density is non-zero, this function automatically updates the mass
of the body.
Contacts are not created until the next time step.</p>
<pre class="source">
Fixture createFixture(FixtureDef def) {
 assert (world.locked == false);

 Fixture fixture = new Fixture();
 fixture.create(this, def);

 if ((flags &amp; ACTIVE_FLAG) == ACTIVE_FLAG) {
   BroadPhase broadPhase = world._contactManager.broadPhase;
   fixture.createProxy(broadPhase, originTransform);
 }

 fixture.next = fixtureList;
 fixtureList = fixture;
 ++fixtureCount;

 fixture.body = this;

 // Adjust mass properties if needed.
 if (fixture.density &gt; 0.0) {
   resetMassData();
 }

 // Let the world know we have a new fixture. This will cause new contacts
 // to be created at the beginning of the next time step.
 world._flags |= World.NEW_FIXTURE;

 return fixture;
}
</pre>
</div>
</div>
<div class="method"><h4 id="createFixtureFromShape">
<button class="show-code">Code</button>
<a href="../box2d/Fixture.html">Fixture</a> <strong>createFixtureFromShape</strong>(<a href="../box2d/Shape.html">Shape</a> shape, [<a href="http://api.dartlang.org/dart_core/double.html" ref="external">double</a> density = 0.0]) <a class="anchor-link" href="#createFixtureFromShape"
              title="Permalink to Body.createFixtureFromShape">#</a></h4>
<div class="doc">
<p>Creates a fixture from a shape and attach it to this body.
This is a convenience function. Use FixtureDef if you need to set
parameters like friction, restitution, user data, or filtering.
If the density is non-zero, this function automatically updates the mass
of the body.</p>
<pre class="source">
Fixture createFixtureFromShape(Shape shape, [double density = 0.0]) {
 _fixDef.shape = shape;
 _fixDef.density = density;

 return createFixture(_fixDef);
}
</pre>
</div>
</div>
<div class="method"><h4 id="destroyFixture">
<button class="show-code">Code</button>
void <strong>destroyFixture</strong>(<a href="../box2d/Fixture.html">Fixture</a> fixture) <a class="anchor-link" href="#destroyFixture"
              title="Permalink to Body.destroyFixture">#</a></h4>
<div class="doc">
<p>Destroy a fixture. This removes the fixture from the broad-phase and
destroys all contacts associated with this fixture. This will
automatically adjust the mass of the body if the body is dynamic and the
fixture has positive density.
All fixtures attached to a body are implicitly destroyed when the body is
destroyed.</p>
<pre class="source">
void destroyFixture(Fixture fixture) {
 assert (world.locked == false);
 if (world.locked == true) {
   return;
 }

 assert (fixture.body == this);

 // Remove the fixture from this body's singly linked list.
 assert (fixtureCount &gt; 0);
 Fixture node = fixtureList;
 Fixture last = null; // java change
 bool found = false;
 while (node != null) {
   if (node == fixture) {
     node = fixture.next;
     found = true;
     break;
   }
   last = node;
   node = node.next;
 }

 // You tried to remove a shape that is not attached to this body.
 assert (found);

 if (last == null) {
   fixtureList = fixture.next;
 } else {
   last.next = fixture.next;
 }

 // Destroy any contacts associated with the fixture.
 ContactEdge edge = contactList;
 while (edge != null) {
   Contact c = edge.contact;
   edge = edge.next;

   Fixture fixtureA = c.fixtureA;
   Fixture fixtureB = c.fixtureB;

   if (fixture == fixtureA || fixture == fixtureB) {
     // This destroys the contact and removes it from
     // this body's contact list.
     world._contactManager.destroy(c);
   }
 }

 if ((flags &amp; ACTIVE_FLAG) == ACTIVE_FLAG) {
   assert (fixture.proxy != null);
   BroadPhase broadPhase = world._contactManager.broadPhase;
   fixture.destroyProxy(broadPhase);
 } else {
   assert (fixture.proxy == null);
 }

 fixture.destroy();
 fixture.body = null;
 fixture.next = null;
 fixture = null;

 --fixtureCount;

 // Reset the mass data.
 resetMassData();
}
</pre>
</div>
</div>
<div class="method"><h4 id="getLinearVelocityFromLocalPoint">
<button class="show-code">Code</button>
<a href="../vector_math_64/Vector2.html">Vector2</a> <strong>getLinearVelocityFromLocalPoint</strong>(<a href="../vector_math_64/Vector2.html">Vector2</a> localPoint) <a class="anchor-link" href="#getLinearVelocityFromLocalPoint"
              title="Permalink to Body.getLinearVelocityFromLocalPoint">#</a></h4>
<div class="doc">
<p>Get the world velocity of a local point.</p>
<p>localPoint: point in local coordinates.
returns the world velocity of a point.</p>
<pre class="source">
Vector2 getLinearVelocityFromLocalPoint(Vector2 localPoint) {
 Vector2 out = new Vector2.zero();
 getLinearVelocityFromLocalPointToOut(localPoint, out);
 return out;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getLinearVelocityFromLocalPointToOut">
<button class="show-code">Code</button>
void <strong>getLinearVelocityFromLocalPointToOut</strong>(<a href="../vector_math_64/Vector2.html">Vector2</a> localPoint, <a href="../vector_math_64/Vector2.html">Vector2</a> out) <a class="anchor-link" href="#getLinearVelocityFromLocalPointToOut"
              title="Permalink to Body.getLinearVelocityFromLocalPointToOut">#</a></h4>
<div class="doc">
<p>Get the world velocity of a local point and store the result in the given
out parameter.</p>
<pre class="source">
void getLinearVelocityFromLocalPointToOut(Vector2 localPoint, Vector2 out) {
 getWorldPointToOut(localPoint, out);
 getLinearVelocityFromWorldPointToOut(out, out);
}
</pre>
</div>
</div>
<div class="method"><h4 id="getLinearVelocityFromWorldPoint">
<button class="show-code">Code</button>
<a href="../vector_math_64/Vector2.html">Vector2</a> <strong>getLinearVelocityFromWorldPoint</strong>(<a href="../vector_math_64/Vector2.html">Vector2</a> worldPoint) <a class="anchor-link" href="#getLinearVelocityFromWorldPoint"
              title="Permalink to Body.getLinearVelocityFromWorldPoint">#</a></h4>
<div class="doc">
<p>Get the world linear velocity of a world point attached to this body.</p>
<p>worldPoint: point in world coordinates.
returns the world velocity of a point.</p>
<pre class="source">
Vector2 getLinearVelocityFromWorldPoint(Vector2 worldPoint) {
 Vector2 out = new Vector2.zero();
 getLinearVelocityFromWorldPointToOut(worldPoint, out);
 return out;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getLinearVelocityFromWorldPointToOut">
<button class="show-code">Code</button>
void <strong>getLinearVelocityFromWorldPointToOut</strong>(<a href="../vector_math_64/Vector2.html">Vector2</a> worldPoint, <a href="../vector_math_64/Vector2.html">Vector2</a> out) <a class="anchor-link" href="#getLinearVelocityFromWorldPointToOut"
              title="Permalink to Body.getLinearVelocityFromWorldPointToOut">#</a></h4>
<div class="doc">
<pre class="source">
void getLinearVelocityFromWorldPointToOut(Vector2 worldPoint, Vector2 out) {
 out.setFrom(worldPoint).sub(sweep.center);
 out.scaleOrthogonalInto(_angularVelocity, out);
 out.add(_linearVelocity);
}
</pre>
</div>
</div>
<div class="method"><h4 id="getLocalPoint">
<button class="show-code">Code</button>
<a href="../vector_math_64/Vector2.html">Vector2</a> <strong>getLocalPoint</strong>(<a href="../vector_math_64/Vector2.html">Vector2</a> worldPoint) <a class="anchor-link" href="#getLocalPoint"
              title="Permalink to Body.getLocalPoint">#</a></h4>
<div class="doc">
<p>Gets a local point relative to the body's origin given a world point.</p>
<p>worldPoint: point in world coordinates.
returns the corresponding local point relative to the body's origin.</p>
<pre class="source">
Vector2 getLocalPoint(Vector2 worldPoint) {
 Vector2 out = new Vector2.zero();
 getLocalPointToOut(worldPoint, out);
 return out;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getLocalPointToOut">
<button class="show-code">Code</button>
void <strong>getLocalPointToOut</strong>(<a href="../vector_math_64/Vector2.html">Vector2</a> worldPoint, <a href="../vector_math_64/Vector2.html">Vector2</a> out) <a class="anchor-link" href="#getLocalPointToOut"
              title="Permalink to Body.getLocalPointToOut">#</a></h4>
<div class="doc">
<p>Gets a local point relative to the body's origin given a world point.
Returns this through the given out parameter.</p>
<pre class="source">
void getLocalPointToOut(Vector2 worldPoint, Vector2 out) {
 Transform.mulTransToOut(originTransform, worldPoint, out);
}
</pre>
</div>
</div>
<div class="method"><h4 id="getLocalVector2">
<button class="show-code">Code</button>
<a href="../vector_math_64/Vector2.html">Vector2</a> <strong>getLocalVector2</strong>(<a href="../vector_math_64/Vector2.html">Vector2</a> worldVector) <a class="anchor-link" href="#getLocalVector2"
              title="Permalink to Body.getLocalVector2">#</a></h4>
<div class="doc">
<p>Gets a local vector given a world vector.</p>
<p>worldVector: vector in world coordinates.
returns the corresponding local vector.</p>
<pre class="source">
Vector2 getLocalVector2(Vector2 worldVector) {
 Vector2 out = new Vector2.zero();
 getLocalVectorToOut(worldVector, out);
 return out;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getLocalVectorToOut">
<button class="show-code">Code</button>
void <strong>getLocalVectorToOut</strong>(<a href="../vector_math_64/Vector2.html">Vector2</a> worldVector, <a href="../vector_math_64/Vector2.html">Vector2</a> out) <a class="anchor-link" href="#getLocalVectorToOut"
              title="Permalink to Body.getLocalVectorToOut">#</a></h4>
<div class="doc">
<p>Gets a local vector given a world vector and stores the result in the given
out parameter.</p>
<pre class="source">
void getLocalVectorToOut(Vector2 worldVector, Vector2 out) {
 originTransform.rotation.transposed().transformed(worldVector,
     out);
}
</pre>
</div>
</div>
<div class="method"><h4 id="getMassData">
<button class="show-code">Code</button>
void <strong>getMassData</strong>(<a href="../box2d/MassData.html">MassData</a> data) <a class="anchor-link" href="#getMassData"
              title="Permalink to Body.getMassData">#</a></h4>
<div class="doc">
<p>Get the mass data of the body. The rotational inertia is relative
to the center of mass. Result is returned through the given out parameter
data.</p>
<pre class="source">
void getMassData(MassData data) {
 data.mass = mass;
 final Vector2 lc = sweep.localCenter;
 data.inertia = _inertia + mass * lc.length2;
 data.center.x = lc.x;
 data.center.y = lc.y;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getWorldPoint">
<button class="show-code">Code</button>
<a href="../vector_math_64/Vector2.html">Vector2</a> <strong>getWorldPoint</strong>(<a href="../vector_math_64/Vector2.html">Vector2</a> localPoint) <a class="anchor-link" href="#getWorldPoint"
              title="Permalink to Body.getWorldPoint">#</a></h4>
<div class="doc">
<p>Get the world coordinates of a point given the local coordinates.</p>
<p>localPoint
  a point on the body measured relative the the body's origin.
returns the same point expressed in world coordinates.</p>
<pre class="source">
Vector2 getWorldPoint(Vector2 localPoint) {
 Vector2 v = new Vector2.zero();
 getWorldPointToOut(localPoint, v);
 return v;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getWorldPointToOut">
<button class="show-code">Code</button>
void <strong>getWorldPointToOut</strong>(<a href="../vector_math_64/Vector2.html">Vector2</a> localPoint, <a href="../vector_math_64/Vector2.html">Vector2</a> out) <a class="anchor-link" href="#getWorldPointToOut"
              title="Permalink to Body.getWorldPointToOut">#</a></h4>
<div class="doc">
<p>Get the world coordinates of a point given the local coordinates to the
given out parameter.</p>
<pre class="source">
void getWorldPointToOut(Vector2 localPoint, Vector2 out) {
 Transform.mulToOut(originTransform, localPoint, out);
}
</pre>
</div>
</div>
<div class="method"><h4 id="getWorldVector2">
<button class="show-code">Code</button>
<a href="../vector_math_64/Vector2.html">Vector2</a> <strong>getWorldVector2</strong>(<a href="../vector_math_64/Vector2.html">Vector2</a> localVector) <a class="anchor-link" href="#getWorldVector2"
              title="Permalink to Body.getWorldVector2">#</a></h4>
<div class="doc">
<p>Get the world coordinates of a vector given the local coordinates.</p>
<p>localVector: a vector fixed in the body.
return the same vector expressed in world coordinates.</p>
<pre class="source">
Vector2 getWorldVector2(Vector2 localVector) {
 Vector2 out = new Vector2.zero();
 getWorldVectorToOut(localVector, out);
 return out;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getWorldVectorToOut">
<button class="show-code">Code</button>
void <strong>getWorldVectorToOut</strong>(<a href="../vector_math_64/Vector2.html">Vector2</a> localVector, <a href="../vector_math_64/Vector2.html">Vector2</a> out) <a class="anchor-link" href="#getWorldVectorToOut"
              title="Permalink to Body.getWorldVectorToOut">#</a></h4>
<div class="doc">
<p>Get the world coordinates of a vector given the local coordinates to the
given out paramater.</p>
<pre class="source">
void getWorldVectorToOut(Vector2 localVector, Vector2 out) {
 originTransform.rotation.transformed(localVector,
     out);
}
</pre>
</div>
</div>
<div class="method"><h4 id="resetMassData">
<button class="show-code">Code</button>
void <strong>resetMassData</strong>() <a class="anchor-link" href="#resetMassData"
              title="Permalink to Body.resetMassData">#</a></h4>
<div class="doc">
<p>This resets the mass properties to the sum of the mass properties of the
fixtures.
This normally does not need to be called unless you called setMassData to
override the mass and you later want to reset the mass.</p>
<pre class="source">
void resetMassData() {
 // Compute mass data from shapes. Each shape has its own density.
 mass = 0.0;
 invMass = 0.0;
 _inertia = 0.0;
 invInertia = 0.0;
 sweep.localCenter.setZero();

 // Static and kinematic bodies have zero mass.
 if (_type == BodyType.STATIC || _type == BodyType.KINEMATIC) {
   sweep.center.setFrom(originTransform.position);
   sweep.centerZero.setFrom(originTransform.position);
   return;
 }

 assert (_type == BodyType.DYNAMIC);

 // Accumulate mass over all fixtures.
 tempCenter.setZero();
 MassData massData = _pmd;
 for (Fixture f = fixtureList; f != null; f = f.next) {
   if (f.density == 0.0) {
     continue;
   }
   f.getMassData(massData);
   mass += massData.mass;
   final temp = new Vector2.copy(massData.center);
   temp.scale(massData.mass);
   tempCenter.add(temp);
   _inertia += massData.inertia;
 }

 // Compute center of mass.
 if (mass &gt; 0.0) {
   invMass = 1.0 / mass;
   tempCenter.scale(invMass);
 } else {
   // Force all dynamic bodies to have a positive mass.
   mass = 1.0;
   invMass = 1.0;
 }

 if (_inertia &gt; 0.0 &amp;&amp; (flags &amp; FIXED_ROTATION_FLAG) == 0) {
   // Center the inertia about the center of mass.
   _inertia -= mass * tempCenter.dot(tempCenter);
   assert (_inertia &gt; 0.0);
   invInertia = 1.0 / _inertia;
 } else {
   _inertia = 0.0;
   invInertia = 0.0;
 }

 // Move center of mass.
 oldCenter.setFrom(sweep.center);
 sweep.localCenter.setFrom(tempCenter);
 Transform.mulToOut(originTransform, sweep.localCenter, sweep.centerZero);
 sweep.center.setFrom(sweep.centerZero);

 // Update center of mass velocity.
 final Vector2 temp = new Vector2.copy(sweep.center);
 temp.sub(oldCenter);
 temp.scaleOrthogonalInto(_angularVelocity, temp);
 _linearVelocity.add(temp);
}
</pre>
</div>
</div>
<div class="method"><h4 id="setTransform">
<button class="show-code">Code</button>
void <strong>setTransform</strong>(<a href="../vector_math_64/Vector2.html">Vector2</a> argPosition, <a href="http://api.dartlang.org/dart_core/double.html" ref="external">double</a> argAngle) <a class="anchor-link" href="#setTransform"
              title="Permalink to Body.setTransform">#</a></h4>
<div class="doc">
<p>Set the position of the body's origin and rotation.
This breaks any contacts and wakes the other bodies.
Manipulating a body's transform may cause non-physical behavior.</p>
<pre class="source">
void setTransform(Vector2 argPosition, double argAngle) {
 assert (world.locked == false);
 if (world.locked == true) {
   return;
 }

 originTransform.rotation.setRotation(argAngle);
 originTransform.position.setFrom(argPosition);

 Transform.mulToOut(originTransform, sweep.localCenter, sweep.centerZero);
 sweep.center.setFrom(sweep.centerZero);

 sweep.angleZero = argAngle;
 sweep.angle = argAngle;

 BroadPhase broadPhase = world._contactManager.broadPhase;
 for (Fixture f = fixtureList; f != null; f = f.next) {
   f.synchronize(broadPhase, originTransform, originTransform);
 }

 world._contactManager.findNewContacts();
}
</pre>
</div>
</div>
<div class="method"><h4 id="shouldCollide">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>shouldCollide</strong>(<a href="../box2d/Body.html">Body</a> other) <a class="anchor-link" href="#shouldCollide"
              title="Permalink to Body.shouldCollide">#</a></h4>
<div class="doc">
<p>This is used to prevent connected bodies from colliding.
It may lie, depending on the collideConnected flag.</p>
<pre class="source">
bool shouldCollide(Body other) {
 // At least one body should be dynamic.
 return !(_type != BodyType.DYNAMIC &amp;&amp; other._type != BodyType.DYNAMIC);
}
</pre>
</div>
</div>
<div class="method"><h4 id="synchronizeFixtures">
<button class="show-code">Code</button>
void <strong>synchronizeFixtures</strong>() <a class="anchor-link" href="#synchronizeFixtures"
              title="Permalink to Body.synchronizeFixtures">#</a></h4>
<div class="doc">
<pre class="source">
void synchronizeFixtures() {
 final Transform xf1 = _pxf;
 xf1.rotation.setRotation(sweep.angleZero);
 xf1.rotation.transformed(sweep.localCenter,
     xf1.position);
 xf1.position.scale(-1.0);
 xf1.position.add(sweep.centerZero);

 BroadPhase broadPhase = world._contactManager.broadPhase;
 for (Fixture f = fixtureList; f != null; f = f.next)
   f.synchronize(broadPhase, xf1, originTransform);
}
</pre>
</div>
</div>
<div class="method"><h4 id="synchronizeTransform">
<button class="show-code">Code</button>
void <strong>synchronizeTransform</strong>() <a class="anchor-link" href="#synchronizeTransform"
              title="Permalink to Body.synchronizeTransform">#</a></h4>
<div class="doc">
<pre class="source">
void synchronizeTransform() {
 final double c = Math.cos(sweep.angle);
 final double s = Math.sin(sweep.angle);
 final Transform t = originTransform;
 final Matrix2 r = t.rotation;
 final Vector2 p = t.position;

 r.setValues(c,s,-s,c);

 p.x = (r.entry(0,0) * sweep.localCenter.x + r.entry(0,1) * sweep.localCenter.y) * -1 +
     sweep.center.x;
 p.y = (r.entry(1,0) * sweep.localCenter.x + r.entry(1,1) * sweep.localCenter.y) * -1 +
     sweep.center.y;
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
