        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Collision class / box2d Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="box2d" data-type="Collision">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../box2d.html">box2d</a> &rsaquo; <a href="../box2d/Collision.html">Collision</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Collision</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class Collision {
 static const int NULL_FEATURE = Settings.MAX_INTEGER;

 final DefaultWorldPool _pool;

 /** Cache used to help warmstart distance. */
 final SimplexCache cache = new SimplexCache();

 /** Distance input and output. */
 final DistanceInput input = new DistanceInput();
 final DistanceOutput output = new DistanceOutput();

 /** A pool of already constructed objects. */
 final EdgeResults results1 = new EdgeResults();
 final EdgeResults results2 = new EdgeResults();
 final List&lt;ClipVertex&gt; incidentEdge =
   new List&lt;ClipVertex&gt;.generate(2, (_) =&gt; new ClipVertex(), growable: false);

 final Vector2 localTangent = new Vector2.zero();
 final Vector2 localNormal = new Vector2.zero();
 final Vector2 planePoint = new Vector2.zero();
 final Vector2 tangent = new Vector2.zero();
 final Vector2 normal = new Vector2.zero();
 final Vector2 normal1 = new Vector2.zero();
 final Vector2 v11 = new Vector2.zero();
 final Vector2 v12 = new Vector2.zero();
 final List&lt;ClipVertex&gt; clipPoints1 =
   new List&lt;ClipVertex&gt;.generate(2, (_) =&gt; new ClipVertex(), growable: false);

 final List&lt;ClipVertex&gt; clipPoints2 =
   new List&lt;ClipVertex&gt;.generate(2, (_) =&gt; new ClipVertex(), growable: false);

 /**
  * Constructs a new Collision object. Should only be constructed once (in the
  * pool). Retrieve from the pool to use.
  */
 Collision._construct(this._pool);

 /**
  * Returns true if the two given shapes overlap.
  */
 bool testOverlap(Shape shapeA, Shape shapeB, Transform transformA,
     Transform transformB) {
   input.proxyA.setFromShape(shapeA);
   input.proxyB.setFromShape(shapeB);
   input.transformA.setFrom(transformA);
   input.transformB.setFrom(transformB);
   input.useRadii = true;

   cache.count = 0;

   _pool.distance.distance(output, cache, input);
   return output.distance &lt; 10.0 * Settings.EPSILON;
 }

 /**
  * Compute the point states given two manifolds. The states pertain to the
  * transition from manifold1 to manifold2. So state1 is either persist or
  * remove while state2 is either add or persist.
  */
 void getPointStates(List&lt;int&gt; state1, List&lt;int&gt; state2,
     Manifold manifold1, Manifold manifold2) {
   for (int i = 0; i &lt; Settings.MAX_MANIFOLD_POINTS; ++i) {
     state1[i] = PointState.NULL_STATE;
     state2[i] = PointState.NULL_STATE;
   }

   // Detect persists and removes.
   for (int i = 0; i &lt; manifold1.pointCount; ++i) {
     ContactID id = manifold1.points[i].id;

     state1[i] = PointState.REMOVE_STATE;

     for (int j = 0; j &lt; manifold2.pointCount; ++j) {
       if (manifold2.points[j].id.isEqual(id)) {
         state1[i] = PointState.PERSIST_STATE;
         break;
       }
     }
   }

   // Detect persists and adds
   for (int i = 0; i &lt; manifold2.pointCount; ++i) {
     ContactID id = manifold2.points[i].id;

     state2[i] = PointState.ADD_STATE;

     for (int j = 0; j &lt; manifold1.pointCount; ++j) {
       if (manifold1.points[j].id.isEqual(id)) {
         state2[i] = PointState.PERSIST_STATE;
         break;
       }
     }
   }
 }

 /**
  * Clipping for contact manifolds.
  * Sutherland-Hodgman clipping.
  */
 static int clipSegmentToLine(List&lt;ClipVertex&gt; vOut, List&lt;ClipVertex&gt; vIn,
     Vector2 norm, double offset) {

   // Start with no output points
   int numOut = 0;

   // Calculate the distance of end points to the line
   double distance0 = norm.dot(vIn[0].v) - offset;
   double distance1 = norm.dot(vIn[1].v) - offset;

   // If the points are behind the plane
   if (distance0 &lt;= 0.0)
     vOut[numOut++].setFrom(vIn[0]);

   if (distance1 &lt;= 0.0)
     vOut[numOut++].setFrom(vIn[1]);

   // If the points are on different sides of the plane
   if (distance0 * distance1 &lt; 0.0) {
     // Find intersection point of edge and plane
     double interp = distance0 / (distance0 - distance1);
     // vOut[numOut].v = vIn[0].v + interp * (vIn[1].v - vIn[0].v);
     vOut[numOut].v.setFrom(vIn[1].v).
         sub(vIn[0].v).scale(interp).add(vIn[0].v);
     final ClipVertex vin = (distance0 &gt; 0.0 ? vIn[0] : vIn[1]);
     vOut[numOut].id.setFrom(vin.id);
     ++numOut;
   }

   return numOut;
 }

 /** Compute the collision manifold between two circles. */
 void collideCircles(Manifold manifold, CircleShape circle1, Transform xfA,
     CircleShape circle2, Transform xfB) {
   manifold.pointCount = 0;

   final Vector2 v = circle1.position;
   final double pAy = xfA.position.y + xfA.rotation.dotRow(1, v);
   final double pAx = xfA.position.x + xfA.rotation.dotRow(0, v);

   final Vector2 v1 = circle2.position;
   final double pBy = xfB.position.y + xfB.rotation.dotRow(1, v1);
   final double pBx = xfB.position.x + xfB.rotation.dotRow(0, v1);

   final double dx = pBx - pAx;
   final double dy = pBy - pAy;

   final double distSqr = dx * dx + dy * dy;

   final double radius = circle1.radius + circle2.radius;
   if (distSqr &gt; radius * radius)
     return;

   manifold.type = ManifoldType.CIRCLES;
   manifold.localPoint.setFrom(circle1.position);
   manifold.localNormal.setZero();
   manifold.pointCount = 1;

   manifold.points[0].localPoint.setFrom(circle2.position);
   manifold.points[0].id.zero();
 }

 /**
  * Compute the collision manifold between a polygon and a circle.
  */
 void collidePolygonAndCircle(Manifold manifold, PolygonShape polygon,
     Transform xfA, CircleShape circle, Transform xfB) {
   manifold.pointCount = 0;
   Vector2 v = circle.position;

   final double cy = xfB.position.y + xfB.rotation.dotRow(1, v);
   final double cx = xfB.position.x + xfB.rotation.dotRow(0, v);
   final Vector2 cpos = new Vector2(cx - xfA.position.x, cy - xfA.position.y);
//    final double bx = xfA.rotation.entry(0,0);
//    final double by = xfA.rotation.entry(1,0);
//    final double b1x = xfA.rotation.entry(0,1);
//    final double b1y = xfA.rotation.entry(1,1);
   final Vector2 cLocal = new Vector2(xfA.rotation.dotColumn(0, cpos),
                                      xfA.rotation.dotColumn(1, cpos));

   // Find the min separating edge.
   int normalIndex = 0;
   double separation = Settings.SMALL_NUMBER;
   final double radius = polygon.radius + circle.radius;
   final int vertexCount = polygon.vertexCount;

   final List&lt;Vector2&gt; vertices = polygon.vertices;
   final List&lt;Vector2&gt; normals = polygon.normals;

   for (int i = 0; i &lt; vertexCount; ++i) {
     final Vector2 vertex = vertices[i];
     final Vector2 temp = cLocal - vertex;
     final Vector2 norm = normals[i];
     final double s = norm.dot(temp);

     // early out
     if (s &gt; radius)
       return;

     if (s &gt; separation) {
       separation = s;
       normalIndex = i;
     }
   }

   // Vertices that subtend the incident face.
   final int vertIndex1 = normalIndex;
   final int vertIndex2 = vertIndex1 + 1 &lt; vertexCount ? vertIndex1 + 1 : 0;
   final Vector2 v1 = vertices[vertIndex1];
   final Vector2 v2 = vertices[vertIndex2];

   // If the center is inside the polygon ...
   if (separation &lt; Settings.EPSILON) {
     manifold.pointCount = 1;
     manifold.type = ManifoldType.FACE_A;

     Vector2 norm = normals[normalIndex];
     manifold.localNormal.x = norm.x;
     manifold.localNormal.y = norm.y;
     manifold.localPoint.x = (v1.x + v2.x) * .5;
     manifold.localPoint.y = (v1.y + v2.y) * .5;
     ManifoldPoint mpoint = manifold.points[0];
     mpoint.localPoint.x = circle.position.x;
     mpoint.localPoint.y = circle.position.y;
     mpoint.id.zero();
     return;
   }

   // Compute barycentric coordinates
   final Vector2 temp = cLocal - v1;
   final Vector2 temp2 = v2 - v1;
   final double u1 = temp.dot(temp2);

   final Vector2 temp3 = cLocal - v2;
   final Vector2 temp4 = v1 - v2;
   final double u2 = temp3.dot(temp4);

   if (u1 &lt;= 0) {
     final Vector2 d = cLocal - v1;
     if ( d.length2 &gt; radius * radius)
       return;

     manifold.pointCount = 1;
     manifold.type = ManifoldType.FACE_A;
     manifold.localNormal.setFrom(cLocal - v1);
     manifold.localNormal.normalize();
     manifold.localPoint.setFrom(v1);
     manifold.points[0].localPoint.setFrom(circle.position);
     manifold.points[0].id.zero();
   } else if (u2 &lt;= 0.0) {
     final Vector2 d = cLocal - v2;
     if ( d.length2 &gt; radius * radius)
       return;

     manifold.pointCount = 1;
     manifold.type = ManifoldType.FACE_A;
     manifold.localNormal.setFrom(cLocal - v2);
     manifold.localNormal.normalize();
     manifold.localPoint.setFrom(v2);
     manifold.points[0].localPoint.setFrom(circle.position);
     manifold.points[0].id.zero();
   } else {
     // Vector2 faceCenter = 0.5 * (v1 + v2);
     // (temp is faceCenter)
     final Vector2 fc = (v1 + v2).scale(0.5);

     final Vector2 t = cLocal - fc;
     final Vector2 norm = normals[vertIndex1];
     separation = t.dot(norm);
     if (separation &gt; radius)
       return;

     manifold.pointCount = 1;
     manifold.type = ManifoldType.FACE_A;
     manifold.localNormal.setFrom(normals[vertIndex1]);
     manifold.localPoint.setFrom(fc);
     manifold.points[0].localPoint.setFrom(circle.position);
     manifold.points[0].id.zero();
   }
 }

 /**
  * Find the separation between poly1 and poly2 for a given edge normal on
  * poly1.
  */
 double edgeSeparation(PolygonShape poly1, Transform xf1, int edge1,
                       PolygonShape poly2, Transform xf2) {
   final int count1 = poly1.vertexCount;
   final List&lt;Vector2&gt; vertices1 = poly1.vertices;
   final List&lt;Vector2&gt; normals1 = poly1.normals;

   final int count2 = poly2.vertexCount;
   final List&lt;Vector2&gt; vertices2 = poly2.vertices;

   assert (0 &lt;= edge1 &amp;&amp; edge1 &lt; count1);
   // Convert normal from poly1's frame into poly2's frame.
   final Matrix2 R = xf1.rotation;
   final Vector2 v = normals1[edge1];
   final Vector2 normal1World = new Vector2(R.dotRow(0, v), R.dotRow(1, v));
   final Matrix2 R1 = xf2.rotation;
   final double normal1x = R1.dotColumn(0, normal1World);
   final double normal1y = R1.dotColumn(1, normal1World);
   // end inline

   // Find support vertex on poly2 for -normal.
   int index = 0;
   double minDot = Settings.BIG_NUMBER;

   for (int i = 0; i &lt; count2; ++i) {
     final Vector2 a = vertices2[i];
     final double dot = a.x * normal1x + a.y * normal1y;
     if (dot &lt; minDot) {
       minDot = dot;
       index = i;
     }
   }

   final Vector2 v3 = vertices1[edge1];
   final double v1y = xf1.position.y + R.dotRow(1, v3);
   final double v1x = xf1.position.x + R.dotRow(0, v3);
   final Vector2 v4 = vertices2[index];
   final double v2y = xf2.position.y + R1.dotRow(1, v4) - v1y;
   final double v2x = xf2.position.x + R1.dotRow(0, v4) - v1x;

   return v2x * normal1World.x + v2y * normal1World.y;
 }

 /**
  * Find the max separation between poly1 and poly2 using edge normals from
  * poly1.
  */
 void findMaxSeparation(EdgeResults results, PolygonShape poly1, Transform xf1,
     PolygonShape poly2, Transform xf2) {
   int count1 = poly1.vertexCount;
   final List&lt;Vector2&gt; normals1 = poly1.normals;
   Vector2 v = poly2.centroid;

   final double predy = xf2.position.y + xf2.rotation.dotRow(1, v);
   final double predx = xf2.position.x + xf2.rotation.dotRow(0, v);
   final Vector2 v1 = poly1.centroid;
   final double tempy = xf1.position.y + xf1.rotation.dotRow(1, v1);
   final double tempx = xf1.position.x + xf1.rotation.dotRow(0, v1);
   final Vector2 d = new Vector2(predx - tempx, predy - tempy);

   final Matrix2 R = xf1.rotation;
   final double dLocal1x = R.dotColumn(0, d);
   final double dLocal1y = R.dotColumn(1, d);

   // Find edge normal on poly1 that has the largest projection onto d.
   int edge = 0;
   double dot;
   double maxDot = Settings.SMALL_NUMBER;
   for (int i = 0; i &lt; count1; i++) {
     final Vector2 norm = normals1[i];
     dot = norm.x * dLocal1x + norm.y * dLocal1y;
     if (dot &gt; maxDot) {
       maxDot = dot;
       edge = i;
     }
   }

   // Get the separation for the edge normal.
   double s = edgeSeparation(poly1, xf1, edge, poly2, xf2);

   // Check the separation for the previous edge normal.
   int prevEdge = edge - 1 &gt;= 0 ? edge - 1 : count1 - 1;
   double sPrev = edgeSeparation(poly1, xf1, prevEdge, poly2, xf2);

   // Check the separation for the next edge normal.
   int nextEdge = edge + 1 &lt; count1 ? edge + 1 : 0;
   double sNext = edgeSeparation(poly1, xf1, nextEdge, poly2, xf2);

   // Find the best edge and the search direction.
   int bestEdge;
   double bestSeparation;
   int increment;
   if (sPrev &gt; s &amp;&amp; sPrev &gt; sNext) {
     increment = -1;
     bestEdge = prevEdge;
     bestSeparation = sPrev;
   } else if (sNext &gt; s) {
     increment = 1;
     bestEdge = nextEdge;
     bestSeparation = sNext;
   } else {
     results.edgeIndex = edge;
     results.separation = s;
     return;
   }

   // Perform a local search for the best edge normal.
   while (true) {
     if (increment == -1)
       edge = bestEdge - 1 &gt;= 0 ? bestEdge - 1 : count1 - 1;
     else
       edge = bestEdge + 1 &lt; count1 ? bestEdge + 1 : 0;

     s = edgeSeparation(poly1, xf1, edge, poly2, xf2);

     if (s &gt; bestSeparation) {
       bestEdge = edge;
       bestSeparation = s;
     } else {
       break;
     }
   }

   results.edgeIndex = bestEdge;
   results.separation = bestSeparation;
 }

 void findIncidentEdge(List&lt;ClipVertex&gt; c, PolygonShape poly1, Transform xf1,
     int edge1, PolygonShape poly2, Transform xf2) {
   int count1 = poly1.vertexCount;
   final List&lt;Vector2&gt; normals1 = poly1.normals;

   int count2 = poly2.vertexCount;
   final List&lt;Vector2&gt; vertices2 = poly2.vertices;
   final List&lt;Vector2&gt; normals2 = poly2.normals;

   assert (0 &lt;= edge1 &amp;&amp; edge1 &lt; count1);

   // Get the normal of the reference edge in poly2's frame.
   xf1.rotation.transformed(normals1[edge1], normal1);
   xf2.rotation.transposed().transformed(normal1, normal1);

   // Find the incident edge on poly2.
   int index = 0;
   double minDot = Settings.BIG_NUMBER;
   for (int i = 0; i &lt; count2; ++i) {
     double dot = normal1.dot(normals2[i]);
     if (dot &lt; minDot) {
       minDot = dot;
       index = i;
     }
   }

   // Build the clip vertices for the incident edge.
   int i1 = index;
   int i2 = i1 + 1 &lt; count2 ? i1 + 1 : 0;

   Transform.mulToOut(xf2, vertices2[i1], c[0].v);
   c[0].id.features.referenceEdge = edge1;
   c[0].id.features.incidentEdge = i1;
   c[0].id.features.incidentVertex = 0;

   Transform.mulToOut(xf2, vertices2[i2], c[1].v);
   c[1].id.features.referenceEdge = edge1;
   c[1].id.features.incidentEdge = i2;
   c[1].id.features.incidentVertex = 1;
 }

 /**
  * Compute the collision manifold between two polygons.
  */
 void collidePolygons(Manifold manifold, PolygonShape polyA, Transform xfA,
    PolygonShape polyB, Transform xfB) {

   manifold.pointCount = 0;
   double totalRadius = polyA.radius + polyB.radius;

   findMaxSeparation(results1, polyA, xfA, polyB, xfB);
   if (results1.separation &gt; totalRadius)
     return;

   findMaxSeparation(results2, polyB, xfB, polyA, xfA);
   if (results2.separation &gt; totalRadius)
     return;

   PolygonShape poly1; // reference polygon
   PolygonShape poly2; // incident polygon
   Transform xf1, xf2;
   int edge1; // reference edge
   int flip;
   double k_relativeTol = 0.98;
   double k_absoluteTol = 0.001;

   if (results2.separation &gt; k_relativeTol * results1.separation +
       k_absoluteTol) {
     poly1 = polyB;
     poly2 = polyA;
     xf1 = xfB;
     xf2 = xfA;
     edge1 = results2.edgeIndex;
     manifold.type = ManifoldType.FACE_B;
     flip = 1;
   } else {
     poly1 = polyA;
     poly2 = polyB;
     xf1 = xfA;
     xf2 = xfB;
     edge1 = results1.edgeIndex;
     manifold.type = ManifoldType.FACE_A;
     flip = 0;
   }

   findIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);

   int count1 = poly1.vertexCount;
   List&lt;Vector2&gt; vertices1 = poly1.vertices;

   v11.setFrom(vertices1[edge1]);
   v12.setFrom(edge1 + 1 &lt; count1 ? vertices1[edge1 + 1] : vertices1[0]);

   localTangent.setFrom(v12).sub(v11);
   localTangent.normalize();

   // Vector2 localNormal = Cross(dv, 1.0);
   localTangent.scaleOrthogonalInto(-1.0, localNormal);

   // Vector2 planePoint = 0.5 * (v11 + v12)
   planePoint.setFrom(v11).add(v12).scale(.5);

   // Vector2 sideNormal = Mul(xf1.rotation, v12 - v11);
   xf1.rotation.transformed(localTangent, tangent);

   // Vector2 frontNormal = Cross(sideNormal, 1.0);
   tangent.scaleOrthogonalInto(-1.0, normal);

   // v11 = Mul(xf1, v11);
   // v12 = Mul(xf1, v12);
   Transform.mulToOut(xf1, v11, v11);
   Transform.mulToOut(xf1, v12, v12);

   // Face offset
   double frontOffset = normal.dot(v11);

   // Side offsets, extended by polytope skin thickness.
   double sideOffset1 = -tangent.dot(v11) + totalRadius;
   double sideOffset2 = tangent.dot(v12) + totalRadius;

   // Clip incident edge against extruded edge1 side edges.
   // ClipVertex clipPoints1[2];
   // ClipVertex clipPoints2[2];
   int np;

   // Clip to box side 1
   // np = ClipSegmentToLine(clipPoints1, incidentEdge, -sideNormal,
   // sideOffset1);
   tangent.negate();
   np = clipSegmentToLine(clipPoints1, incidentEdge, tangent, sideOffset1);
   tangent.negate();

   if (np &lt; 2)
     return;

   // Clip to negative box side 1
   np = clipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);

   if (np &lt; 2)
     return;

   // Now clipPoints2 contains the clipped points.
   manifold.localNormal.setFrom(localNormal);
   manifold.localPoint.setFrom(planePoint);

   int pointCount = 0;
   for (int i = 0; i &lt; Settings.MAX_MANIFOLD_POINTS; ++i) {
     double separation = normal.dot(clipPoints2[i].v) - frontOffset;

     if (separation &lt;= totalRadius) {
       ManifoldPoint cp = manifold.points[pointCount];
       Transform.mulTransToOut(xf2, clipPoints2[i].v, cp.localPoint);
       // cp.localPoint = MulT(xf2, clipPoints2[i].v);
       cp.id.setFrom(clipPoints2[i].id);
       cp.id.features.flip = flip;
       ++pointCount;
     }
   }

   manifold.pointCount = pointCount;
 }
}
</pre>
</div>
<div>
<h3>Static Properties</h3>
<div class="field"><h4 id="NULL_FEATURE">
<button class="show-code">Code</button>
const <a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a>         <strong>NULL_FEATURE</strong> <a class="anchor-link"
            href="#NULL_FEATURE"
            title="Permalink to Collision.NULL_FEATURE">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static const int NULL_FEATURE = Settings.MAX_INTEGER
</pre>
</div>
</div>
</div>
<div>
<h3>Static Methods</h3>
<div class="method"><h4 id="clipSegmentToLine">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a> <strong>clipSegmentToLine</strong>(<a href="http://api.dartlang.org/dart_core/List.html" ref="external">List</a>&lt;<a href="../box2d/ClipVertex.html">ClipVertex</a>&gt; vOut, <a href="http://api.dartlang.org/dart_core/List.html" ref="external">List</a>&lt;<a href="../box2d/ClipVertex.html">ClipVertex</a>&gt; vIn, <a href="../vector_math_64/Vector2.html">Vector2</a> norm, <a href="http://api.dartlang.org/dart_core/double.html" ref="external">double</a> offset) <a class="anchor-link" href="#clipSegmentToLine"
              title="Permalink to Collision.clipSegmentToLine">#</a></h4>
<div class="doc">
<p>Clipping for contact manifolds.
Sutherland-Hodgman clipping.</p>
<pre class="source">
static int clipSegmentToLine(List&lt;ClipVertex&gt; vOut, List&lt;ClipVertex&gt; vIn,
   Vector2 norm, double offset) {

 // Start with no output points
 int numOut = 0;

 // Calculate the distance of end points to the line
 double distance0 = norm.dot(vIn[0].v) - offset;
 double distance1 = norm.dot(vIn[1].v) - offset;

 // If the points are behind the plane
 if (distance0 &lt;= 0.0)
   vOut[numOut++].setFrom(vIn[0]);

 if (distance1 &lt;= 0.0)
   vOut[numOut++].setFrom(vIn[1]);

 // If the points are on different sides of the plane
 if (distance0 * distance1 &lt; 0.0) {
   // Find intersection point of edge and plane
   double interp = distance0 / (distance0 - distance1);
   // vOut[numOut].v = vIn[0].v + interp * (vIn[1].v - vIn[0].v);
   vOut[numOut].v.setFrom(vIn[1].v).
       sub(vIn[0].v).scale(interp).add(vIn[0].v);
   final ClipVertex vin = (distance0 &gt; 0.0 ? vIn[0] : vIn[1]);
   vOut[numOut].id.setFrom(vin.id);
   ++numOut;
 }

 return numOut;
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="cache">
<button class="show-code">Code</button>
final <a href="../box2d/SimplexCache.html">SimplexCache</a>         <strong>cache</strong> <a class="anchor-link"
            href="#cache"
            title="Permalink to Collision.cache">#</a>
        </h4>
        <div class="doc">
<p>Cache used to help warmstart distance. </p>
<pre class="source">
final SimplexCache cache = new SimplexCache()
</pre>
</div>
</div>
<div class="field"><h4 id="clipPoints1">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/List.html" ref="external">List</a>&lt;<a href="../box2d/ClipVertex.html">ClipVertex</a>&gt;         <strong>clipPoints1</strong> <a class="anchor-link"
            href="#clipPoints1"
            title="Permalink to Collision.clipPoints1">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final List&lt;ClipVertex&gt; clipPoints1 =
 new List&lt;ClipVertex&gt;.generate(2, (_) =&gt; new ClipVertex(), growable: false)
</pre>
</div>
</div>
<div class="field"><h4 id="clipPoints2">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/List.html" ref="external">List</a>&lt;<a href="../box2d/ClipVertex.html">ClipVertex</a>&gt;         <strong>clipPoints2</strong> <a class="anchor-link"
            href="#clipPoints2"
            title="Permalink to Collision.clipPoints2">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final List&lt;ClipVertex&gt; clipPoints2 =
 new List&lt;ClipVertex&gt;.generate(2, (_) =&gt; new ClipVertex(), growable: false)
</pre>
</div>
</div>
<div class="field"><h4 id="incidentEdge">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/List.html" ref="external">List</a>&lt;<a href="../box2d/ClipVertex.html">ClipVertex</a>&gt;         <strong>incidentEdge</strong> <a class="anchor-link"
            href="#incidentEdge"
            title="Permalink to Collision.incidentEdge">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final List&lt;ClipVertex&gt; incidentEdge =
 new List&lt;ClipVertex&gt;.generate(2, (_) =&gt; new ClipVertex(), growable: false)
</pre>
</div>
</div>
<div class="field"><h4 id="input">
<button class="show-code">Code</button>
final <a href="../box2d/DistanceInput.html">DistanceInput</a>         <strong>input</strong> <a class="anchor-link"
            href="#input"
            title="Permalink to Collision.input">#</a>
        </h4>
        <div class="doc">
<p>Distance input and output. </p>
<pre class="source">
final DistanceInput input = new DistanceInput()
</pre>
</div>
</div>
<div class="field"><h4 id="localNormal">
<button class="show-code">Code</button>
final <a href="../vector_math_64/Vector2.html">Vector2</a>         <strong>localNormal</strong> <a class="anchor-link"
            href="#localNormal"
            title="Permalink to Collision.localNormal">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final Vector2 localNormal = new Vector2.zero()
</pre>
</div>
</div>
<div class="field"><h4 id="localTangent">
<button class="show-code">Code</button>
final <a href="../vector_math_64/Vector2.html">Vector2</a>         <strong>localTangent</strong> <a class="anchor-link"
            href="#localTangent"
            title="Permalink to Collision.localTangent">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final Vector2 localTangent = new Vector2.zero()
</pre>
</div>
</div>
<div class="field"><h4 id="normal">
<button class="show-code">Code</button>
final <a href="../vector_math_64/Vector2.html">Vector2</a>         <strong>normal</strong> <a class="anchor-link"
            href="#normal"
            title="Permalink to Collision.normal">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final Vector2 normal = new Vector2.zero()
</pre>
</div>
</div>
<div class="field"><h4 id="normal1">
<button class="show-code">Code</button>
final <a href="../vector_math_64/Vector2.html">Vector2</a>         <strong>normal1</strong> <a class="anchor-link"
            href="#normal1"
            title="Permalink to Collision.normal1">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final Vector2 normal1 = new Vector2.zero()
</pre>
</div>
</div>
<div class="field"><h4 id="output">
<button class="show-code">Code</button>
final <a href="../box2d/DistanceOutput.html">DistanceOutput</a>         <strong>output</strong> <a class="anchor-link"
            href="#output"
            title="Permalink to Collision.output">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final DistanceOutput output = new DistanceOutput()
</pre>
</div>
</div>
<div class="field"><h4 id="planePoint">
<button class="show-code">Code</button>
final <a href="../vector_math_64/Vector2.html">Vector2</a>         <strong>planePoint</strong> <a class="anchor-link"
            href="#planePoint"
            title="Permalink to Collision.planePoint">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final Vector2 planePoint = new Vector2.zero()
</pre>
</div>
</div>
<div class="field"><h4 id="results1">
<button class="show-code">Code</button>
final <a href="../box2d/EdgeResults.html">EdgeResults</a>         <strong>results1</strong> <a class="anchor-link"
            href="#results1"
            title="Permalink to Collision.results1">#</a>
        </h4>
        <div class="doc">
<p>A pool of already constructed objects. </p>
<pre class="source">
final EdgeResults results1 = new EdgeResults()
</pre>
</div>
</div>
<div class="field"><h4 id="results2">
<button class="show-code">Code</button>
final <a href="../box2d/EdgeResults.html">EdgeResults</a>         <strong>results2</strong> <a class="anchor-link"
            href="#results2"
            title="Permalink to Collision.results2">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final EdgeResults results2 = new EdgeResults()
</pre>
</div>
</div>
<div class="field"><h4 id="tangent">
<button class="show-code">Code</button>
final <a href="../vector_math_64/Vector2.html">Vector2</a>         <strong>tangent</strong> <a class="anchor-link"
            href="#tangent"
            title="Permalink to Collision.tangent">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final Vector2 tangent = new Vector2.zero()
</pre>
</div>
</div>
<div class="field"><h4 id="v11">
<button class="show-code">Code</button>
final <a href="../vector_math_64/Vector2.html">Vector2</a>         <strong>v11</strong> <a class="anchor-link"
            href="#v11"
            title="Permalink to Collision.v11">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final Vector2 v11 = new Vector2.zero()
</pre>
</div>
</div>
<div class="field"><h4 id="v12">
<button class="show-code">Code</button>
final <a href="../vector_math_64/Vector2.html">Vector2</a>         <strong>v12</strong> <a class="anchor-link"
            href="#v12"
            title="Permalink to Collision.v12">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final Vector2 v12 = new Vector2.zero()
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="collideCircles">
<button class="show-code">Code</button>
void <strong>collideCircles</strong>(<a href="../box2d/Manifold.html">Manifold</a> manifold, <a href="../box2d/CircleShape.html">CircleShape</a> circle1, <a href="../box2d/Transform.html">Transform</a> xfA, <a href="../box2d/CircleShape.html">CircleShape</a> circle2, <a href="../box2d/Transform.html">Transform</a> xfB) <a class="anchor-link" href="#collideCircles"
              title="Permalink to Collision.collideCircles">#</a></h4>
<div class="doc">
<p>Compute the collision manifold between two circles. </p>
<pre class="source">
void collideCircles(Manifold manifold, CircleShape circle1, Transform xfA,
   CircleShape circle2, Transform xfB) {
 manifold.pointCount = 0;

 final Vector2 v = circle1.position;
 final double pAy = xfA.position.y + xfA.rotation.dotRow(1, v);
 final double pAx = xfA.position.x + xfA.rotation.dotRow(0, v);

 final Vector2 v1 = circle2.position;
 final double pBy = xfB.position.y + xfB.rotation.dotRow(1, v1);
 final double pBx = xfB.position.x + xfB.rotation.dotRow(0, v1);

 final double dx = pBx - pAx;
 final double dy = pBy - pAy;

 final double distSqr = dx * dx + dy * dy;

 final double radius = circle1.radius + circle2.radius;
 if (distSqr &gt; radius * radius)
   return;

 manifold.type = ManifoldType.CIRCLES;
 manifold.localPoint.setFrom(circle1.position);
 manifold.localNormal.setZero();
 manifold.pointCount = 1;

 manifold.points[0].localPoint.setFrom(circle2.position);
 manifold.points[0].id.zero();
}
</pre>
</div>
</div>
<div class="method"><h4 id="collidePolygonAndCircle">
<button class="show-code">Code</button>
void <strong>collidePolygonAndCircle</strong>(<a href="../box2d/Manifold.html">Manifold</a> manifold, <a href="../box2d/PolygonShape.html">PolygonShape</a> polygon, <a href="../box2d/Transform.html">Transform</a> xfA, <a href="../box2d/CircleShape.html">CircleShape</a> circle, <a href="../box2d/Transform.html">Transform</a> xfB) <a class="anchor-link" href="#collidePolygonAndCircle"
              title="Permalink to Collision.collidePolygonAndCircle">#</a></h4>
<div class="doc">
<p>Compute the collision manifold between a polygon and a circle.</p>
<pre class="source">
void collidePolygonAndCircle(Manifold manifold, PolygonShape polygon,
   Transform xfA, CircleShape circle, Transform xfB) {
 manifold.pointCount = 0;
 Vector2 v = circle.position;

 final double cy = xfB.position.y + xfB.rotation.dotRow(1, v);
 final double cx = xfB.position.x + xfB.rotation.dotRow(0, v);
 final Vector2 cpos = new Vector2(cx - xfA.position.x, cy - xfA.position.y);
//    final double bx = xfA.rotation.entry(0,0);
//    final double by = xfA.rotation.entry(1,0);
//    final double b1x = xfA.rotation.entry(0,1);
//    final double b1y = xfA.rotation.entry(1,1);
 final Vector2 cLocal = new Vector2(xfA.rotation.dotColumn(0, cpos),
                                    xfA.rotation.dotColumn(1, cpos));

 // Find the min separating edge.
 int normalIndex = 0;
 double separation = Settings.SMALL_NUMBER;
 final double radius = polygon.radius + circle.radius;
 final int vertexCount = polygon.vertexCount;

 final List&lt;Vector2&gt; vertices = polygon.vertices;
 final List&lt;Vector2&gt; normals = polygon.normals;

 for (int i = 0; i &lt; vertexCount; ++i) {
   final Vector2 vertex = vertices[i];
   final Vector2 temp = cLocal - vertex;
   final Vector2 norm = normals[i];
   final double s = norm.dot(temp);

   // early out
   if (s &gt; radius)
     return;

   if (s &gt; separation) {
     separation = s;
     normalIndex = i;
   }
 }

 // Vertices that subtend the incident face.
 final int vertIndex1 = normalIndex;
 final int vertIndex2 = vertIndex1 + 1 &lt; vertexCount ? vertIndex1 + 1 : 0;
 final Vector2 v1 = vertices[vertIndex1];
 final Vector2 v2 = vertices[vertIndex2];

 // If the center is inside the polygon ...
 if (separation &lt; Settings.EPSILON) {
   manifold.pointCount = 1;
   manifold.type = ManifoldType.FACE_A;

   Vector2 norm = normals[normalIndex];
   manifold.localNormal.x = norm.x;
   manifold.localNormal.y = norm.y;
   manifold.localPoint.x = (v1.x + v2.x) * .5;
   manifold.localPoint.y = (v1.y + v2.y) * .5;
   ManifoldPoint mpoint = manifold.points[0];
   mpoint.localPoint.x = circle.position.x;
   mpoint.localPoint.y = circle.position.y;
   mpoint.id.zero();
   return;
 }

 // Compute barycentric coordinates
 final Vector2 temp = cLocal - v1;
 final Vector2 temp2 = v2 - v1;
 final double u1 = temp.dot(temp2);

 final Vector2 temp3 = cLocal - v2;
 final Vector2 temp4 = v1 - v2;
 final double u2 = temp3.dot(temp4);

 if (u1 &lt;= 0) {
   final Vector2 d = cLocal - v1;
   if ( d.length2 &gt; radius * radius)
     return;

   manifold.pointCount = 1;
   manifold.type = ManifoldType.FACE_A;
   manifold.localNormal.setFrom(cLocal - v1);
   manifold.localNormal.normalize();
   manifold.localPoint.setFrom(v1);
   manifold.points[0].localPoint.setFrom(circle.position);
   manifold.points[0].id.zero();
 } else if (u2 &lt;= 0.0) {
   final Vector2 d = cLocal - v2;
   if ( d.length2 &gt; radius * radius)
     return;

   manifold.pointCount = 1;
   manifold.type = ManifoldType.FACE_A;
   manifold.localNormal.setFrom(cLocal - v2);
   manifold.localNormal.normalize();
   manifold.localPoint.setFrom(v2);
   manifold.points[0].localPoint.setFrom(circle.position);
   manifold.points[0].id.zero();
 } else {
   // Vector2 faceCenter = 0.5 * (v1 + v2);
   // (temp is faceCenter)
   final Vector2 fc = (v1 + v2).scale(0.5);

   final Vector2 t = cLocal - fc;
   final Vector2 norm = normals[vertIndex1];
   separation = t.dot(norm);
   if (separation &gt; radius)
     return;

   manifold.pointCount = 1;
   manifold.type = ManifoldType.FACE_A;
   manifold.localNormal.setFrom(normals[vertIndex1]);
   manifold.localPoint.setFrom(fc);
   manifold.points[0].localPoint.setFrom(circle.position);
   manifold.points[0].id.zero();
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="collidePolygons">
<button class="show-code">Code</button>
void <strong>collidePolygons</strong>(<a href="../box2d/Manifold.html">Manifold</a> manifold, <a href="../box2d/PolygonShape.html">PolygonShape</a> polyA, <a href="../box2d/Transform.html">Transform</a> xfA, <a href="../box2d/PolygonShape.html">PolygonShape</a> polyB, <a href="../box2d/Transform.html">Transform</a> xfB) <a class="anchor-link" href="#collidePolygons"
              title="Permalink to Collision.collidePolygons">#</a></h4>
<div class="doc">
<p>Compute the collision manifold between two polygons.</p>
<pre class="source">
void collidePolygons(Manifold manifold, PolygonShape polyA, Transform xfA,
  PolygonShape polyB, Transform xfB) {

 manifold.pointCount = 0;
 double totalRadius = polyA.radius + polyB.radius;

 findMaxSeparation(results1, polyA, xfA, polyB, xfB);
 if (results1.separation &gt; totalRadius)
   return;

 findMaxSeparation(results2, polyB, xfB, polyA, xfA);
 if (results2.separation &gt; totalRadius)
   return;

 PolygonShape poly1; // reference polygon
 PolygonShape poly2; // incident polygon
 Transform xf1, xf2;
 int edge1; // reference edge
 int flip;
 double k_relativeTol = 0.98;
 double k_absoluteTol = 0.001;

 if (results2.separation &gt; k_relativeTol * results1.separation +
     k_absoluteTol) {
   poly1 = polyB;
   poly2 = polyA;
   xf1 = xfB;
   xf2 = xfA;
   edge1 = results2.edgeIndex;
   manifold.type = ManifoldType.FACE_B;
   flip = 1;
 } else {
   poly1 = polyA;
   poly2 = polyB;
   xf1 = xfA;
   xf2 = xfB;
   edge1 = results1.edgeIndex;
   manifold.type = ManifoldType.FACE_A;
   flip = 0;
 }

 findIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);

 int count1 = poly1.vertexCount;
 List&lt;Vector2&gt; vertices1 = poly1.vertices;

 v11.setFrom(vertices1[edge1]);
 v12.setFrom(edge1 + 1 &lt; count1 ? vertices1[edge1 + 1] : vertices1[0]);

 localTangent.setFrom(v12).sub(v11);
 localTangent.normalize();

 // Vector2 localNormal = Cross(dv, 1.0);
 localTangent.scaleOrthogonalInto(-1.0, localNormal);

 // Vector2 planePoint = 0.5 * (v11 + v12)
 planePoint.setFrom(v11).add(v12).scale(.5);

 // Vector2 sideNormal = Mul(xf1.rotation, v12 - v11);
 xf1.rotation.transformed(localTangent, tangent);

 // Vector2 frontNormal = Cross(sideNormal, 1.0);
 tangent.scaleOrthogonalInto(-1.0, normal);

 // v11 = Mul(xf1, v11);
 // v12 = Mul(xf1, v12);
 Transform.mulToOut(xf1, v11, v11);
 Transform.mulToOut(xf1, v12, v12);

 // Face offset
 double frontOffset = normal.dot(v11);

 // Side offsets, extended by polytope skin thickness.
 double sideOffset1 = -tangent.dot(v11) + totalRadius;
 double sideOffset2 = tangent.dot(v12) + totalRadius;

 // Clip incident edge against extruded edge1 side edges.
 // ClipVertex clipPoints1[2];
 // ClipVertex clipPoints2[2];
 int np;

 // Clip to box side 1
 // np = ClipSegmentToLine(clipPoints1, incidentEdge, -sideNormal,
 // sideOffset1);
 tangent.negate();
 np = clipSegmentToLine(clipPoints1, incidentEdge, tangent, sideOffset1);
 tangent.negate();

 if (np &lt; 2)
   return;

 // Clip to negative box side 1
 np = clipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);

 if (np &lt; 2)
   return;

 // Now clipPoints2 contains the clipped points.
 manifold.localNormal.setFrom(localNormal);
 manifold.localPoint.setFrom(planePoint);

 int pointCount = 0;
 for (int i = 0; i &lt; Settings.MAX_MANIFOLD_POINTS; ++i) {
   double separation = normal.dot(clipPoints2[i].v) - frontOffset;

   if (separation &lt;= totalRadius) {
     ManifoldPoint cp = manifold.points[pointCount];
     Transform.mulTransToOut(xf2, clipPoints2[i].v, cp.localPoint);
     // cp.localPoint = MulT(xf2, clipPoints2[i].v);
     cp.id.setFrom(clipPoints2[i].id);
     cp.id.features.flip = flip;
     ++pointCount;
   }
 }

 manifold.pointCount = pointCount;
}
</pre>
</div>
</div>
<div class="method"><h4 id="edgeSeparation">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/double.html" ref="external">double</a> <strong>edgeSeparation</strong>(<a href="../box2d/PolygonShape.html">PolygonShape</a> poly1, <a href="../box2d/Transform.html">Transform</a> xf1, <a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a> edge1, <a href="../box2d/PolygonShape.html">PolygonShape</a> poly2, <a href="../box2d/Transform.html">Transform</a> xf2) <a class="anchor-link" href="#edgeSeparation"
              title="Permalink to Collision.edgeSeparation">#</a></h4>
<div class="doc">
<p>Find the separation between poly1 and poly2 for a given edge normal on
poly1.</p>
<pre class="source">
double edgeSeparation(PolygonShape poly1, Transform xf1, int edge1,
                     PolygonShape poly2, Transform xf2) {
 final int count1 = poly1.vertexCount;
 final List&lt;Vector2&gt; vertices1 = poly1.vertices;
 final List&lt;Vector2&gt; normals1 = poly1.normals;

 final int count2 = poly2.vertexCount;
 final List&lt;Vector2&gt; vertices2 = poly2.vertices;

 assert (0 &lt;= edge1 &amp;&amp; edge1 &lt; count1);
 // Convert normal from poly1's frame into poly2's frame.
 final Matrix2 R = xf1.rotation;
 final Vector2 v = normals1[edge1];
 final Vector2 normal1World = new Vector2(R.dotRow(0, v), R.dotRow(1, v));
 final Matrix2 R1 = xf2.rotation;
 final double normal1x = R1.dotColumn(0, normal1World);
 final double normal1y = R1.dotColumn(1, normal1World);
 // end inline

 // Find support vertex on poly2 for -normal.
 int index = 0;
 double minDot = Settings.BIG_NUMBER;

 for (int i = 0; i &lt; count2; ++i) {
   final Vector2 a = vertices2[i];
   final double dot = a.x * normal1x + a.y * normal1y;
   if (dot &lt; minDot) {
     minDot = dot;
     index = i;
   }
 }

 final Vector2 v3 = vertices1[edge1];
 final double v1y = xf1.position.y + R.dotRow(1, v3);
 final double v1x = xf1.position.x + R.dotRow(0, v3);
 final Vector2 v4 = vertices2[index];
 final double v2y = xf2.position.y + R1.dotRow(1, v4) - v1y;
 final double v2x = xf2.position.x + R1.dotRow(0, v4) - v1x;

 return v2x * normal1World.x + v2y * normal1World.y;
}
</pre>
</div>
</div>
<div class="method"><h4 id="findIncidentEdge">
<button class="show-code">Code</button>
void <strong>findIncidentEdge</strong>(<a href="http://api.dartlang.org/dart_core/List.html" ref="external">List</a>&lt;<a href="../box2d/ClipVertex.html">ClipVertex</a>&gt; c, <a href="../box2d/PolygonShape.html">PolygonShape</a> poly1, <a href="../box2d/Transform.html">Transform</a> xf1, <a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a> edge1, <a href="../box2d/PolygonShape.html">PolygonShape</a> poly2, <a href="../box2d/Transform.html">Transform</a> xf2) <a class="anchor-link" href="#findIncidentEdge"
              title="Permalink to Collision.findIncidentEdge">#</a></h4>
<div class="doc">
<pre class="source">
void findIncidentEdge(List&lt;ClipVertex&gt; c, PolygonShape poly1, Transform xf1,
   int edge1, PolygonShape poly2, Transform xf2) {
 int count1 = poly1.vertexCount;
 final List&lt;Vector2&gt; normals1 = poly1.normals;

 int count2 = poly2.vertexCount;
 final List&lt;Vector2&gt; vertices2 = poly2.vertices;
 final List&lt;Vector2&gt; normals2 = poly2.normals;

 assert (0 &lt;= edge1 &amp;&amp; edge1 &lt; count1);

 // Get the normal of the reference edge in poly2's frame.
 xf1.rotation.transformed(normals1[edge1], normal1);
 xf2.rotation.transposed().transformed(normal1, normal1);

 // Find the incident edge on poly2.
 int index = 0;
 double minDot = Settings.BIG_NUMBER;
 for (int i = 0; i &lt; count2; ++i) {
   double dot = normal1.dot(normals2[i]);
   if (dot &lt; minDot) {
     minDot = dot;
     index = i;
   }
 }

 // Build the clip vertices for the incident edge.
 int i1 = index;
 int i2 = i1 + 1 &lt; count2 ? i1 + 1 : 0;

 Transform.mulToOut(xf2, vertices2[i1], c[0].v);
 c[0].id.features.referenceEdge = edge1;
 c[0].id.features.incidentEdge = i1;
 c[0].id.features.incidentVertex = 0;

 Transform.mulToOut(xf2, vertices2[i2], c[1].v);
 c[1].id.features.referenceEdge = edge1;
 c[1].id.features.incidentEdge = i2;
 c[1].id.features.incidentVertex = 1;
}
</pre>
</div>
</div>
<div class="method"><h4 id="findMaxSeparation">
<button class="show-code">Code</button>
void <strong>findMaxSeparation</strong>(<a href="../box2d/EdgeResults.html">EdgeResults</a> results, <a href="../box2d/PolygonShape.html">PolygonShape</a> poly1, <a href="../box2d/Transform.html">Transform</a> xf1, <a href="../box2d/PolygonShape.html">PolygonShape</a> poly2, <a href="../box2d/Transform.html">Transform</a> xf2) <a class="anchor-link" href="#findMaxSeparation"
              title="Permalink to Collision.findMaxSeparation">#</a></h4>
<div class="doc">
<p>Find the max separation between poly1 and poly2 using edge normals from
poly1.</p>
<pre class="source">
void findMaxSeparation(EdgeResults results, PolygonShape poly1, Transform xf1,
   PolygonShape poly2, Transform xf2) {
 int count1 = poly1.vertexCount;
 final List&lt;Vector2&gt; normals1 = poly1.normals;
 Vector2 v = poly2.centroid;

 final double predy = xf2.position.y + xf2.rotation.dotRow(1, v);
 final double predx = xf2.position.x + xf2.rotation.dotRow(0, v);
 final Vector2 v1 = poly1.centroid;
 final double tempy = xf1.position.y + xf1.rotation.dotRow(1, v1);
 final double tempx = xf1.position.x + xf1.rotation.dotRow(0, v1);
 final Vector2 d = new Vector2(predx - tempx, predy - tempy);

 final Matrix2 R = xf1.rotation;
 final double dLocal1x = R.dotColumn(0, d);
 final double dLocal1y = R.dotColumn(1, d);

 // Find edge normal on poly1 that has the largest projection onto d.
 int edge = 0;
 double dot;
 double maxDot = Settings.SMALL_NUMBER;
 for (int i = 0; i &lt; count1; i++) {
   final Vector2 norm = normals1[i];
   dot = norm.x * dLocal1x + norm.y * dLocal1y;
   if (dot &gt; maxDot) {
     maxDot = dot;
     edge = i;
   }
 }

 // Get the separation for the edge normal.
 double s = edgeSeparation(poly1, xf1, edge, poly2, xf2);

 // Check the separation for the previous edge normal.
 int prevEdge = edge - 1 &gt;= 0 ? edge - 1 : count1 - 1;
 double sPrev = edgeSeparation(poly1, xf1, prevEdge, poly2, xf2);

 // Check the separation for the next edge normal.
 int nextEdge = edge + 1 &lt; count1 ? edge + 1 : 0;
 double sNext = edgeSeparation(poly1, xf1, nextEdge, poly2, xf2);

 // Find the best edge and the search direction.
 int bestEdge;
 double bestSeparation;
 int increment;
 if (sPrev &gt; s &amp;&amp; sPrev &gt; sNext) {
   increment = -1;
   bestEdge = prevEdge;
   bestSeparation = sPrev;
 } else if (sNext &gt; s) {
   increment = 1;
   bestEdge = nextEdge;
   bestSeparation = sNext;
 } else {
   results.edgeIndex = edge;
   results.separation = s;
   return;
 }

 // Perform a local search for the best edge normal.
 while (true) {
   if (increment == -1)
     edge = bestEdge - 1 &gt;= 0 ? bestEdge - 1 : count1 - 1;
   else
     edge = bestEdge + 1 &lt; count1 ? bestEdge + 1 : 0;

   s = edgeSeparation(poly1, xf1, edge, poly2, xf2);

   if (s &gt; bestSeparation) {
     bestEdge = edge;
     bestSeparation = s;
   } else {
     break;
   }
 }

 results.edgeIndex = bestEdge;
 results.separation = bestSeparation;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getPointStates">
<button class="show-code">Code</button>
void <strong>getPointStates</strong>(<a href="http://api.dartlang.org/dart_core/List.html" ref="external">List</a>&lt;<a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a>&gt; state1, <a href="http://api.dartlang.org/dart_core/List.html" ref="external">List</a>&lt;<a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a>&gt; state2, <a href="../box2d/Manifold.html">Manifold</a> manifold1, <a href="../box2d/Manifold.html">Manifold</a> manifold2) <a class="anchor-link" href="#getPointStates"
              title="Permalink to Collision.getPointStates">#</a></h4>
<div class="doc">
<p>Compute the point states given two manifolds. The states pertain to the
transition from manifold1 to manifold2. So state1 is either persist or
remove while state2 is either add or persist.</p>
<pre class="source">
void getPointStates(List&lt;int&gt; state1, List&lt;int&gt; state2,
   Manifold manifold1, Manifold manifold2) {
 for (int i = 0; i &lt; Settings.MAX_MANIFOLD_POINTS; ++i) {
   state1[i] = PointState.NULL_STATE;
   state2[i] = PointState.NULL_STATE;
 }

 // Detect persists and removes.
 for (int i = 0; i &lt; manifold1.pointCount; ++i) {
   ContactID id = manifold1.points[i].id;

   state1[i] = PointState.REMOVE_STATE;

   for (int j = 0; j &lt; manifold2.pointCount; ++j) {
     if (manifold2.points[j].id.isEqual(id)) {
       state1[i] = PointState.PERSIST_STATE;
       break;
     }
   }
 }

 // Detect persists and adds
 for (int i = 0; i &lt; manifold2.pointCount; ++i) {
   ContactID id = manifold2.points[i].id;

   state2[i] = PointState.ADD_STATE;

   for (int j = 0; j &lt; manifold1.pointCount; ++j) {
     if (manifold1.points[j].id.isEqual(id)) {
       state2[i] = PointState.PERSIST_STATE;
       break;
     }
   }
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="testOverlap">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>testOverlap</strong>(<a href="../box2d/Shape.html">Shape</a> shapeA, <a href="../box2d/Shape.html">Shape</a> shapeB, <a href="../box2d/Transform.html">Transform</a> transformA, <a href="../box2d/Transform.html">Transform</a> transformB) <a class="anchor-link" href="#testOverlap"
              title="Permalink to Collision.testOverlap">#</a></h4>
<div class="doc">
<p>Returns true if the two given shapes overlap.</p>
<pre class="source">
bool testOverlap(Shape shapeA, Shape shapeB, Transform transformA,
   Transform transformB) {
 input.proxyA.setFromShape(shapeA);
 input.proxyB.setFromShape(shapeB);
 input.transformA.setFrom(transformA);
 input.transformB.setFrom(transformB);
 input.useRadii = true;

 cache.count = 0;

 _pool.distance.distance(output, cache, input);
 return output.distance &lt; 10.0 * Settings.EPSILON;
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
