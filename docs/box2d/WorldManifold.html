        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>WorldManifold class / box2d Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="box2d" data-type="WorldManifold">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../box2d.html">box2d</a> &rsaquo; <a href="../box2d/WorldManifold.html">WorldManifold</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>WorldManifold</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class WorldManifold {
 /**
  * World vector pointing from A to B
  */
 vec2 normal;

 /**
  * World contact points (points of intersection)
  */
 final List&lt;vec2&gt; points;

 /**
  * Constructs a new WorldManifold.
  */
 WorldManifold()
     : normal = new vec2.zero(),
       points = new List&lt;vec2&gt;.generate(
           Settings.MAX_MANIFOLD_POINTS, (i) =&gt; new vec2.zero());

 void initialize(Manifold manifold, Transform xfA, num radiusA, Transform xfB,
     num radiusB) {
   radiusA = radiusA.toDouble();
   radiusB = radiusB.toDouble();
   switch (manifold.type) {
     case ManifoldType.CIRCLES:
       normal.setValues(1.0, 0.0);
       final vec2 pointA = xfA.position + xfA.rotation * manifold.localPoint;
       final vec2 pointB = xfB.position + xfB.rotation * manifold.points[0].localPoint;

       if (distance2(pointA, pointB) &gt; Settings.EPSILON * Settings.EPSILON) {
         normal.setFrom(pointB).sub(pointA);
         normal.normalize();
       }

       final vec2 cA = normal * radiusA + pointA;
       final vec2 cB = -normal * radiusB + pointB;

       points[0].setFrom(cA).add(cB).scale(0.5);
       return;
     case ManifoldType.FACE_A:
       normal = xfA.rotation * manifold.localNormal;
       final vec2 planePoint = xfA.position + xfA.rotation * manifold.localPoint;

       // NOTE: the below still creates new vectors.
       for (int i = 0; i &lt; manifold.pointCount; ++i) {
         final vec2 clipPoint = xfB.position + xfB.rotation * manifold.points[i].localPoint;

         num scalar = radiusA - ((clipPoint.x - planePoint.x) *
             normal.x + (clipPoint.y - planePoint.y) * normal.y);

         vec2 cA = normal * scalar + clipPoint;
         vec2 cB = normal * (-radiusB) + clipPoint;

         points[i] = (cA + cB).scale(0.5);
       }

       return;
     case ManifoldType.FACE_B :
       final mat2 R = xfB.rotation;
       normal = R * manifold.localNormal;
       final vec2 v = manifold.localPoint;
       final vec2 planePoint = xfB.position + xfB.rotation * v;

       // TODO(dominic): Some vector cleanup here.
       for (int i = 0; i &lt; manifold.pointCount; ++i) {
         vec2 clipPoint = xfA.position + xfA.rotation * manifold.points[i].localPoint;

         num scalar = radiusB - ((clipPoint.x - planePoint.x) * normal.x +
             (clipPoint.y - planePoint.y) * normal.y);

         vec2 cB = normal * scalar + clipPoint;
         vec2 cA = normal * (-radiusA) + clipPoint;

         points[i] = (cA + cB).scale(0.5);
       }
       // Ensure normal points from A to B.
       normal.negate();
       break;
    }
 }
}
</pre>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="WorldManifold">
<button class="show-code">Code</button>
new <strong>WorldManifold</strong>() <a class="anchor-link" href="#WorldManifold"
              title="Permalink to WorldManifold.WorldManifold">#</a></h4>
<div class="doc">
<p>Constructs a new WorldManifold.</p>
<pre class="source">
WorldManifold()
   : normal = new vec2.zero(),
     points = new List&lt;vec2&gt;.generate(
         Settings.MAX_MANIFOLD_POINTS, (i) =&gt; new vec2.zero());
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="normal">
<button class="show-code">Code</button>
<a href="../vector_math/vec2.html">vec2</a>         <strong>normal</strong> <a class="anchor-link"
            href="#normal"
            title="Permalink to WorldManifold.normal">#</a>
        </h4>
        <div class="doc">
<p>World vector pointing from A to B</p>
<pre class="source">
vec2 normal
</pre>
</div>
</div>
<div class="field"><h4 id="points">
<button class="show-code">Code</button>
final List&lt;<a href="../vector_math/vec2.html">vec2</a>&gt;         <strong>points</strong> <a class="anchor-link"
            href="#points"
            title="Permalink to WorldManifold.points">#</a>
        </h4>
        <div class="doc">
<p>World contact points (points of intersection)</p>
<pre class="source">
final List&lt;vec2&gt; points
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="initialize">
<button class="show-code">Code</button>
void <strong>initialize</strong>(<a href="../box2d/Manifold.html">Manifold</a> manifold, <a href="../box2d/Transform.html">Transform</a> xfA, num radiusA, <a href="../box2d/Transform.html">Transform</a> xfB, num radiusB) <a class="anchor-link" href="#initialize"
              title="Permalink to WorldManifold.initialize">#</a></h4>
<div class="doc">
<pre class="source">
void initialize(Manifold manifold, Transform xfA, num radiusA, Transform xfB,
   num radiusB) {
 radiusA = radiusA.toDouble();
 radiusB = radiusB.toDouble();
 switch (manifold.type) {
   case ManifoldType.CIRCLES:
     normal.setValues(1.0, 0.0);
     final vec2 pointA = xfA.position + xfA.rotation * manifold.localPoint;
     final vec2 pointB = xfB.position + xfB.rotation * manifold.points[0].localPoint;

     if (distance2(pointA, pointB) &gt; Settings.EPSILON * Settings.EPSILON) {
       normal.setFrom(pointB).sub(pointA);
       normal.normalize();
     }

     final vec2 cA = normal * radiusA + pointA;
     final vec2 cB = -normal * radiusB + pointB;

     points[0].setFrom(cA).add(cB).scale(0.5);
     return;
   case ManifoldType.FACE_A:
     normal = xfA.rotation * manifold.localNormal;
     final vec2 planePoint = xfA.position + xfA.rotation * manifold.localPoint;

     // NOTE: the below still creates new vectors.
     for (int i = 0; i &lt; manifold.pointCount; ++i) {
       final vec2 clipPoint = xfB.position + xfB.rotation * manifold.points[i].localPoint;

       num scalar = radiusA - ((clipPoint.x - planePoint.x) *
           normal.x + (clipPoint.y - planePoint.y) * normal.y);

       vec2 cA = normal * scalar + clipPoint;
       vec2 cB = normal * (-radiusB) + clipPoint;

       points[i] = (cA + cB).scale(0.5);
     }

     return;
   case ManifoldType.FACE_B :
     final mat2 R = xfB.rotation;
     normal = R * manifold.localNormal;
     final vec2 v = manifold.localPoint;
     final vec2 planePoint = xfB.position + xfB.rotation * v;

     // TODO(dominic): Some vector cleanup here.
     for (int i = 0; i &lt; manifold.pointCount; ++i) {
       vec2 clipPoint = xfA.position + xfA.rotation * manifold.points[i].localPoint;

       num scalar = radiusB - ((clipPoint.x - planePoint.x) * normal.x +
           (clipPoint.y - planePoint.y) * normal.y);

       vec2 cB = normal * scalar + clipPoint;
       vec2 cA = normal * (-radiusA) + clipPoint;

       points[i] = (cA + cB).scale(0.5);
     }
     // Ensure normal points from A to B.
     normal.negate();
     break;
  }
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
