{"name":"vector_math_operations","qualifiedName":"vector_math/vector_math_operations","comment":"","variables":{},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{}},"classes":{"class":[{"name":"Matrix44SIMDOperations","qualifiedName":"vector_math/vector_math_operations.Matrix44SIMDOperations","preview":"<p>Static methods operating on 4x4 matrices packed column major into a\nFloat32x4List.</p>"},{"name":"Matrix44Operations","qualifiedName":"vector_math/vector_math_operations.Matrix44Operations","preview":"<p>Static methods operating on 4x4 matrices packed column major into a\nFloat32List.</p>"}],"typedef":{},"error":[]},"packageName":"vector_math","packageIntro":"<h1>vector_math</h1>\n<p><a href=\"https://drone.io/johnmccutchan/vector_math/latest\">!<a href=\"https://drone.io/johnmccutchan/vector_math/status.png\">Build Status</a></a></p>\n<h2>Introduction</h2>\n<p>A Vector math library for 2D and 3D applications.</p>\n<h2>Features</h2><ul><li>2D,3D, and 4D vector and matrix types.</li><li>Quaternion type for animating rotations.</li><li>Collision detection: AABB, rays, spheres, ...</li><li>Flexible getters and setters, for example, <code>`position.xwz = color.grb;</code>`.</li><li>Fully documented.</li><li>Well tested.</li><li>Heavily optimized.</li></ul>\n<h2>Libraries using vector_math</h2><ul><li><a href=\"http://github.com/johnmccutchan/spectre\">Spectre</a></li><li><a href=\"https://github.com/threeDart/\">Three.dart</a></li><li><a href=\"https://github.com/dart-lang/dart-box2d\">Box2D</a></li></ul>\n<h2>Getting Started</h2>\n<p>1\\. Add the following to your project's <strong>pubspec.yaml</strong> and run <code>`pub get</code>`.</p>\n<pre><code>dependencies:\n  vector_math: any\n</code></pre>\n<p>If you want to stay on the latest developent version, add a dependency to the \nGit repository. You may also need to use it if another library uses the Git \ndependency.</p>\n<pre><code>dependencies:\n  vector_math:\n    git: https://github.com/johnmccutchan/vector_math.git\n</code></pre>\n<p>2\\. Add the correct import for your project. </p>\n<pre><code>import 'package:vector_math/vector_math.dart';\n</code></pre>\n<h2>Documentation</h2>\n<p>Read the <a href=\"http://johnmccutchan.github.io/vector_math.html\">docs</a></p>\n<h2>Examples</h2>\n<p>1\\. Using the GLSL getter and setter syntax.</p>\n<pre><code>import 'package:vector_math/vector_math.dart';\n\nvoid main() {\n\tVector3 x = new Vector3.zero(); // Zero vector\n\tVector4 y = new Vector4.all(4.0); // Vector with 4.0 in all lanes\n\tx.zyx = y.xzz; // Sets z,y,x the values in x,z,z\n}\n</code></pre>\n<p>2\\. Transforming a vector.</p>\n<pre><code>import 'dart:math';\nimport 'package:vector_math/vector_math.dart';\n\nvoid main() {\n\t// Rotation of PI/2 degrees around the Y axis followed by a \n\t// translation of (5.0, 2.0, 3.0).\n\tMatrix4 T = new Matrix4.rotationY(PI*0.5).translate(5.0, 2.0, 3.0);\n\t// A point.\n\tVector3 position = new Vector3(1.0, 1.0, 1.0);\n\t// Transform position by T.\n\tT.transform3(position);\n}\n</code></pre>\n<p>3\\. Invert a matrix</p>\n<pre><code>import 'dart:math';\nimport 'package:vector_math/vector_math.dart';\n\nvoid main() {\n\t// Rotation of 90 degrees around the Y axis followed by a \n\t// translation of (5.0, 2.0, 3.0).\n\tMatrix4 T = new Matrix4.rotationY(PI*0.5).translate(5.0, 2.0, 3.0);\n\t// Invert T.\n\tT.invert();\n\t// Invert just the rotation in T.\n\tT.invertRotation();\n}\n</code></pre>\n<p>4\\. Rotate a vector using a quaternion</p>\n<pre><code>import 'dart:math';\nimport 'package:vector_math/vector_math.dart';\n\nvoid main() {\n\t// The X axis.\n\tVector3 axis = new Vector3(1.0, 0.0, 0.0);\n\t// 90 degrees.\n\tdouble angle = PI/2.0;\n\t// Quaternion encoding a 90 degree rotation along the X axis. \n\tQuaternion q = new Quaternion.axisAngle(axis, angle);\n\t// A point.\n\tVector3 point = new Vector3(1.0, 1.0, 1.0);\n\t// Rotate point by q.\n\tq.rotate(point);\n}\n</code></pre>\n<p>5\\. Check if two axis aligned bounding boxes intersect</p>\n<pre><code>import 'package:vector_math/vector_math.dart';\n\nvoid main() {\n\t// Define the first box with a minimum and a maximum.\n\tAabb2 aabbOne = new Aabb2.minMax(new Vector2.zero(), new Vector2(4.0, 4.0));\n\t// Define the second box\n\tAabb2 aabbTwo = new Aabb2.minMax(new Vector2(5.0, 5.0), new Vector2(6.0, 6.0));\n\t// Extend the second box to contain a point\n\taabbTwo.hullPoint(new Vector2(3.0, 3.0));\n\t// Check if the two boxes intersect, returns true in this case.\n\tbool intersect = aabbOne.intersectsWithAabb2(aabbTwo);\n}\n</code></pre>\n<p>6\\. Check where a ray and a sphere intersect</p>\n<pre><code>import 'package:vector_math/vector_math.dart';\n\nvoid main() {\n\t// Define a ray starting at the origin and going into positive x-direction.\n\tRay ray = new Ray.originDirection(new Vector3.zero(), new Vector3(1.0, 0.0, 0.0));\n\t// Defines a sphere with the center (5.0 0.0 0.0) and a radius of 2.\n\tSphere sphere = new Sphere.centerRadius(new Vector3(5.0, 0.0, 0.0), 2);\n\t// Checks if the ray intersect with the sphere and returns the distance of the \n\t// intersection from the origin of the ray. Would return null if no intersection\n\t// is found.\n\tdouble distancFromOrigin = ray.intersectsWithSphere(sphere);\n\t// Evaluate the position of the intersection, in this case (3.0 0.0 0.0).\n\tVector3 position = ray.at(distancFromOrigin);\n}\n</code></pre>\n<p>7\\. Work with colors</p>\n<pre><code>import 'package:vector_math/vector_math.dart';\n\nvoid main() {\n\t// Access a build-in color, colors are stored in 4-dimensional vectors.\n\tVector4 red = Colors.red;\n\tVector4 gray = new Vector4.zero();\n\t// Convert the red color to a grayscaled color.\n\tColors.toGrayscale(red, gray);\n\t// Parse a blue color from a hex string.\n\tVector4 blue = new Vector4.zero();\n\tColors.fromHexString('#0000FF', blue);\n\t// Convert the blue color from RGB to HSL.\n\tColors.rgbToHsl(blue, blue);\n\t// Reduce the lightness of the color by 50%.\n\tblue.z *= 0.5;\n\t// Convert the HSL color back to RGB.\n\tColors.hslToRgb(blue, blue);\n}\n</code></pre>"}